#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Copyright (C) 2012 Karsten-Kai KÃ¶nig <kkoenig@posteo.de>

This file is part of keepassc.

keepassc is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or at your 
option) any later version.

keepassc is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with keepassc.  If not, see <http://www.gnu.org/licenses/>.
'''

import webbrowser
from curses import *
from _curses import error
from curses.ascii import NL, DEL, SP
from datetime import date
from getpass import getpass
from optparse import OptionParser
from os import chdir, getcwd, geteuid, listdir, mkdir
from os.path import isdir, isfile, expanduser, realpath
from pwd import getpwuid
from socket import gethostname
from subprocess import Popen, PIPE
from sys import exit, stdout

from kppy import *

__doc__ = '''This program gives you access to your KeePass 1.x or 
          KeePassX databases through a nice curses interface.

          It is completely controllable with the keyboard.

         '''

class App(object):
    '''This class represents the whole application.'''
    def __init__(self):
        '''The __init__-method. 

        It just initializes some variables and settings and changes
        the working directory to /var/empty to prevent coredumps as
        normal user.

        '''

        self.stdscr = initscr()
        self.ysize, self.xsize = self.stdscr.getmaxyx()
        self.group_win = newwin(self.ysize-1, int(self.xsize/3), 1, 0)
        self.entry_win = newwin(int(2*(self.ysize-1)/3), int(2*self.xsize/3), 
                                1, int(self.xsize/3))
        self.info_win = newwin(int((self.ysize-1)/3), int(2*self.xsize/3),
                               int(2*(self.ysize-1)/3), int(self.xsize/3))
        try:
            curs_set(0)
        except:
            print('Invisible cursor not supported')
        raw()
        noecho()
        self.stdscr.keypad(1)
        self.group_win.keypad(1)
        self.entry_win.keypad(1)
        start_color()
        use_default_colors() #TODO: Set time in .config/keepassc
        init_pair(1, -1, -1)
        init_pair(2, 2, -1)
        init_pair(3, 0, 1)
        init_pair(4, 6, -1)
        init_pair(5, 0, 6)
        init_pair(6, 0, 7)
        self.stdscr.bkgd(1)
        self.group_win.bkgd(1)
        self.entry_win.bkgd(1)
        self.info_win.bkgd(1)
        self.stdscr.timeout(20000) #TODO: Set time in .config/keepassc

        self.last_file = None
        self.loginname = getpwuid(geteuid())[0]
        self.hostname = gethostname()
        self.cur_dir = getcwd()
        self.db = None
        self.cb = None
        self.del_cb = False 

        chdir('/var/empty')
    
    def resize_all(self):
        self.ysize, self.xsize = self.stdscr.getmaxyx()
        self.group_win.resize(self.ysize-1, int(self.xsize/3))
        self.entry_win.resize(int(2*(self.ysize-1)/3), int(2*self.xsize/3))
        self.info_win.resize(int((self.ysize-1)/3), int(self.xsize/3)-2)
        self.group_win.mvwin(1,0)
        self.entry_win.mvwin(1, int(self.xsize/3))
        self.info_win.mvwin(int(2*(self.ysize-1)/3), int(self.xsize/3))

    def del_clipboard(self):
        cb_p = Popen('xsel', stdout = PIPE)
        cb = cb_p.stdout.read().decode()
        if self.del_cb is True and cb == self.cb:
            Popen(['xsel', '-pc'])
            Popen(['xsel', '-bc'])
            self.cb = None
            self.del_cb = False
            
    def any_key(self):
        '''If any key is needed.'''

        while True:
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
            if e == -1:
                self.del_clipboard()
            elif e == 4:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            else:
                break

    def draw_text(self, changed, *misc):
        '''This method is a wrapper to display some text on stdscr.

        misc is a list that should consist of 3-tuples which holds            
        text to display.
        (1st element: y-coordinate, 2nd: x-coordinate, 3rd: text)

        '''

        if changed is True:
            cur_dir = self.cur_dir+'*'
        else:
            cur_dir = self.cur_dir
        try:
            self.stdscr.clear()
            self.stdscr.addstr(0,0, self.loginname+'@'+self.hostname+':', 
                               color_pair(2))
            self.stdscr.addstr(0, len(self.loginname+'@'+self.hostname+':'),
                               cur_dir)
            for i,j,k in misc:
                self.stdscr.addstr(i,j, k)
        except:
            pass
        finally:
            self.stdscr.refresh()

    def get_string(self, edit = '', std = ''):
        '''This method is used to get user input.

        edit is the string to edit and std is text
        which should be displayed in front of edit.
        (std edit)

        '''

        offset = len(std)
        e = ''
        while e != NL:
            if e == KEY_BACKSPACE or e == DEL and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                self.del_clipboard()
            elif e == 4:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == '':
                pass
            elif e == KEY_RESIZE:
                self.resize_all()
            elif e == KEY_F5:
                return False
            else:
                edit += chr(e)

            self.draw_text(False, (1,0,std+edit))
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
        return edit

    def get_password(self, std, needed = True):
        '''This method is used to get a password.

        The pasword will not be displayed during typing.

        std is a string that should be displayed. If needed is True it
        is not possible to return an emptry string.

        '''

        self.draw_text(False, (1,0, std))

        password = ''
        e = ''
        while e != NL or (len(password) == 0 and needed is True):
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
            if e == KEY_BACKSPACE or e == DEL and len(password) != 0:
                password = password[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == '':
                pass
            elif e == -1:
                self.del_clipboard()
            elif e == 4:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.ysize, self.xsize = self.stdscr.getmaxyx()
                self.group_win.resize(self.ysize-1, int(self.xsize/3))
                self.entry_win.resize(int(2*(self.ysize-1)/3),
                                      int(2*self.xsize/3))
                self.info_win.resize(int((self.ysize-1)/3),
                                     int(self.xsize/3)-2)
                self.group_win.mvwin(1,0)
                self.entry_win.mvwin(1,int(self.ysize/3))
                self.info_win.mvwin(int(2*(self.ysize-1)/3), int(self.ysize/3))
            elif e == KEY_F5:
                return False
            else:
                password += chr(e)
                if ord(password[-1]) == NL:
                    password = password[:-1]
        return password

    def gen_pass(self):
        while True:
            items = self.gen_check_menu(((1,0, 'Include numbers'),
                                           (2,0, 'Enforce capitalized letters'),
                                           (3,0, 'Include special symbols')),
                                           (5,0, 'Type space to un-/check'),
                                           (6,0, 'Type enter to enter options'))
            if items is False:
                return False
            length = self.get_num('Password length: ')
            if length is False:
                continue
            options = '-s'
            if options[0] == 0:
                options += '0'
            else:
                options += 'n'
            if options[1] == 0:
                options += 'A'
            else:
                options += 'c'
            if options[2] == 1:
                options += 'y'

            return (Popen(['pwgen', options, str(length), '1'], 
                              stdout = PIPE).stdout.read().decode()[:-1])

    def get_exp_date(self, *exp):
        '''This method is used to get an expiration date for entries.

        exp is used to display an actual expiration date.

        '''

        pass_y = False
        pass_mon = False
        goto_last = False
        while True:
            if pass_y is False:
                edit = ''
                e = KEY_BACKSPACE
                while e != NL:
                    if e == KEY_BACKSPACE and len(edit) != 0:
                        edit = edit[:-1]
                    elif e == KEY_BACKSPACE or e == DEL:
                        pass
                    elif e == -1:
                        self.del_clipboard()
                    elif e == 4:
                        self.del_clipboard()
                        if self.db is not None:
                            self.db_close()
                        self.close()
                    elif e == KEY_RESIZE:
                        self.resize_all()
                    elif e == KEY_F5:
                        return False
                    elif len(edit) < 4 and e >= 48 and e <= 57:
                        edit += chr(e)
                    self.draw_text(False,
                                   (1,0, 'Special date 2999-12-28 means that the '
                                         'expires never.'),
                                   (3,0, 'Year: '+edit))
                    if exp:
                        try:
                            self.stdscr.addstr(2,0, 'Actual expiration date: '+
                                                str(exp[0])+'-'+str(exp[1])+'-'+
                                                str(exp[2]))
                        except:
                            pass
                        finally:
                            self.stdscr.refresh()
                    try:
                        e = self.stdscr.getch()
                    except KeyboardInterrupt:
                        e = 4
                    if e == NL and edit == '':
                        e = KEY_BACKSPACE
                        continue
                y = int(edit)
                pass_y = True 
                
            if pass_mon is False:
                edit = ''
                e = KEY_BACKSPACE
                while e != NL:
                    if e == KEY_BACKSPACE or e == DEL and len(edit) != 0:
                        edit = edit[:-1]
                    elif e == KEY_BACKSPACE or e == DEL:
                        pass
                    elif e == -1:
                        self.del_clipboard()
                    elif e == 4:
                        self.del_clipboard()
                        if self.db is not None:
                            self.db_close()
                        self.close()
                    elif e == KEY_RESIZE:
                        self.resize_all()
                    elif e == KEY_F5:
                        pass_y = False
                        goto_last = True
                        break
                    elif len(edit) < 2 and e >= 48 and e <= 57:
                        edit += chr(e)
                    self.draw_text(False,
                                   (1,0, 'Special date 2999-12-28 means that the '
                                         'expires never.'),
                                   (3,0, 'Year: '+str(y)),
                                   (4,0, 'Month: '+edit))
                    if exp:
                        try:
                            self.stdscr.addstr(2,0, 'Actual expiration date: '+
                                                str(exp[0])+'-'+str(exp[1])+'-'+
                                                str(exp[2]))
                        except:
                            pass
                        finally:
                            self.stdscr.refresh()
                    try:
                        e = self.stdscr.getch()
                    except KeyboardInterrupt:
                        e = 4

                    if e == NL and edit == '':
                        e = KEY_BACKSPACE
                        continue
                    elif e == NL and (int(edit) > 12 or int(edit) < 1):
                        self.draw_text(False,
                                       (1,0, 'Month must be between 1 and 12. Press '
                                             'any key.'))
                        self.any_key()
                        e = ''
                if goto_last is True:
                    goto_last = False
                    continue
                mon = int(edit)
                pass_mon = True

            edit = ''
            e = KEY_BACKSPACE
            while e != NL:
                if e == KEY_BACKSPACE  or e == DEL and len(edit) != 0:
                    edit = edit[:-1]
                elif e == KEY_BACKSPACE or e == DEL:
                    pass
                elif e == -1:
                    self.del_clipboard()
                elif e == 4:
                    self.del_clipboard()
                    if self.db is not None:
                        self.db_close()
                    self.close()
                elif e == KEY_RESIZE:
                    self.resize_all()
                elif e == KEY_F5:
                    pass_mon = False
                    goto_last = True
                    break
                elif len(edit) < 2 and e >= 48 and e <= 57:
                    edit += chr(e)
                self.draw_text(False,
                               (1,0, 'Special date 2999-12-28 means that the '
                                     'expires never.'),
                               (3,0, 'Year: '+str(y)),
                               (4,0, 'Month: '+str(mon)),
                               (5,0, 'Day: '+edit))
                if exp:
                    try:
                        self.stdscr.addstr(2,0, 'Actual expiration date: '+
                                            str(exp[0])+'-'+str(exp[1])+'-'+
                                            str(exp[2]))
                    except:
                        pass
                    finally:
                        self.stdscr.refresh()
                try:
                    e = self.stdscr.getch()
                except KeyboardInterrupt:
                    e = 4
               
                if e == NL and edit == '':
                    e = KEY_BACKSPACE
                    continue
                elif (e == NL and (mon == 1 or mon == 3 or mon == 5 or mon == 7 or
                    mon == 8 or mon == 10 or mon == 12) and (int(edit) > 31 or
                    int(edit) < 0)):
                    self.draw_text(False,
                                   (1,0, 'Day must be between 1 and 31. Press '
                                         'any key.'))
                    self.any_key()
                    e = ''
                elif (e == NL and mon == 2 and (int(edit) > 28 or int(edit) < 0)):
                    self.draw_text(False,
                                   (1,0, 'Day must be between 1 and 28. Press '
                                         'any key.'))
                    self.any_key()
                    e = ''
                elif (e == NL and (mon == 4 or mon == 6 or mon == 9 or
                      mon == 11) and (int(edit) > 30 or int(edit) < 0)):
                    self.draw_text(False,
                                   (1,0, 'Day must be between 1 and 30. Press '
                                         'any key.'))
                    self.any_key()
                    e = ''
            if goto_last is True:
                goto_last = False
                pass_mon = False
                continue
            d = int(edit)
            break
        return (y,mon,d)

    def get_num(self, std = '', edit = ''):
        edit = ''
        e = KEY_BACKSPACE
        while e != NL:
            if e == KEY_BACKSPACE and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                self.del_clipboard()
            elif e == 4:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            elif e == KEY_F5:
                return False
            elif len(edit) < 4 and e >= 48 and e <= 57:
                edit += chr(e)
            self.draw_text(False,
                           (1,0, std+edit))
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
            if e == NL and edit == '':
                e = KEY_BACKSPACE
                continue
        return int(edit)

    def gen_menu(self, misc, *add):
        '''A universal method to generate a menu.

        misc is a tupel of triples (y, x, 'text')

        add are more tuples but the content should not be accessable

        '''

        if len(misc) == 0:
            return False
        highlight = 1
        h_color = 6
        n_color = 1
        e = ''
        while e != NL:
            try:
                self.stdscr.clear()
                self.stdscr.addstr(0,0, self.loginname+'@'+self.hostname+':', 
                                   color_pair(2))
                self.stdscr.addstr(0,
                                   len(self.loginname+'@'+self.hostname+':'),
                                   self.cur_dir)
                for i,j,k in misc:
                    if i == highlight:
                        self.stdscr.addstr(i,j,k, color_pair(h_color))
                    else:
                        self.stdscr.addstr(i,j,k, color_pair(n_color))
                for i,j,k in add:
                    self.stdscr.addstr(i,j,k)
            except:
                pass
            finally:
                self.stdscr.refresh()
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
            if e == -1:
                self.del_clipboard()
            elif e == 4:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            elif e == KEY_F5:
                return False
            elif e == NL:
                return highlight
            elif e == KEY_DOWN and highlight < len(misc):
                highlight += 1
            elif e == KEY_UP and highlight > 1:
                highlight -= 1
            elif 49 <= e <= 48 + len(misc): # ASCII(49) = 1 ...
                return e - 48

    def gen_check_menu(self, misc, *add):
        if len(misc) == 0:
            return False
        items = []
        for i in range(len(misc)):
            items.append(0)
        highlight = 1
        h_color = 6
        n_color = 1
        e = ''
        while e != NL:
            try:
                self.stdscr.clear()
                self.stdscr.addstr(0,0, self.loginname+'@'+self.hostname+':', 
                                   color_pair(2))
                self.stdscr.addstr(0,
                                   len(self.loginname+'@'+self.hostname+':'),
                                   self.cur_dir)
                for i,j,k in misc:
                    if items[i-1] == 0:
                        check = '[ ]'
                    else:
                        check = '[X]'
                    if i == highlight:
                        self.stdscr.addstr(i,j,check+k, color_pair(h_color))
                    else:
                        self.stdscr.addstr(i,j,check+k, color_pair(n_color))
                for i,j,k in add:
                    self.stdscr.addstr(i,j,k)
            except:
                pass
            finally:
                self.stdscr.refresh()
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
            if e == -1:
                self.del_clipboard()
            elif e == 4:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            elif e == KEY_F5:
                return False
            elif e == SP:
                if items[highlight-1] == 0:
                    items[highlight-1] = 1
                else:
                    items[highlight-1] = 0
            elif e == KEY_DOWN and highlight < len(misc):
                highlight += 1
            elif e == KEY_UP and highlight > 1:
                highlight -= 1
            elif e == NL:
                return items

    def main_loop(self, kdb_file = None):
        '''The main loop. The program alway return to this method.'''

        if kdb_file is not None:
            self.cur_dir = kdb_file
            if self.open_file() is True:
                self.db_browser()
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
        while True:
            try:
                handler = open(expanduser('~/.config/keepassc'), 'r')
                self.last_file = handler.readline() #TODO: Read other configs
            except:
                self.last_file = None
            finally:
                handler.close()
            menu = self.gen_menu(((1,0, 'Open existing database (1)'),
                                  (2,0, 'Create new database (2)'),
                                  (3,0, 'Quit (3)')),
                                  (5,0, 'Type \'F1\' for help inside the file '
                                        'or database browser.'),
                                  (6,0, 'Type \'F5\' to return to the previous'
                                        'dialog at any time'))
            if menu == 1:
                if self.open_db() is False:
                    continue
                self.db_browser()
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
            elif menu == 2:
                while True:
                    auth = self.gen_menu((
                           (1,0, 'Use a password (1)'),
                           (2,0, 'Use a keyfile (2)'),
                           (3,0, 'Use both (3)')))
                    self.db = KPDB(new = True)
                    if auth is False:
                        break
                    if auth == 1 or auth == 3:
                        while True:
                            password = self.get_password('Password: ')
                            if password is False:
                                break
                            confirm = self.get_password('Confirm: ')
                            if confirm is False:
                                break
                            if password == confirm:
                                self.db.password = password
                                break
                            else:
                                self.draw_text(False,
                                               (1,0, 'Passwords didn\' match!'),
                                               (3,0, 'Press any key'))
                                self.any_key()
                        if auth != 3: 
                            self.db.keyfile = None
                    if password is False or confirm is False:
                        continue
                    if auth == 2 or auth == 3:
                        while True:
                            filepath = self.get_filepath(False, True)
                            if filepath is False:
                                break
                            elif not isfile(filepath):
                                self.draw_text(False,
                                               (1,0, 'That\' not a file!'),
                                               (3,0, 'Press any key'))
                                self.any_key()
                                continue
                            break
                        if filepath is False:
                            continue
                        self.db.keyfile = filepath
                        if auth != 3: 
                            self.db.password = None

                    if auth is not False:
                        self.db_browser()
                        last = self.cur_dir.split('/')[-1]
                        self.cur_dir = self.cur_dir[:-len(last)-1]
                    else:
                        self.db = None
                    break
            elif menu == 3 or menu is False:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()

    def open_db(self):
        ''' This method opens a database.'''

        while True:
            if self.last_file is None:
                nav = self.gen_menu((
                        (1,0, 'Use the file browser (1)'),
                        (2,0, 'Type direct path (2)')))
            else:
                nav = self.gen_menu((
                        (1,0, 'Use the file browser (1)'),
                        (2,0, 'Type direct path (2)'),
                        (3,0, 'Use '+self.last_file+' (3)')))
            if nav == 1:
                filepath = self.browser()
                if filepath is False:
                    continue
                self.cur_dir = filepath
                if self.open_file() is False:
                    continue
            elif nav == 2:
                filepath = self.get_direct_filepath()
                if filepath is False:
                    continue
                elif filepath[-4:] != '.kdb' or isdir(filepath):
                    self.draw_text(False,
                                   (1,0, 'Need path to a kdb-file!'),
                                   (3,0, 'Press any key'))
                    self.any_key()
                    continue
                else:
                    self.cur_dir = filepath
                    if self.open_file() is False:
                        continue
            elif nav == 3:
                self.cur_dir = self.last_file
                if self.open_file() is False:
                    continue
            else:
                return False
            return True

    def get_filepath(self, ask_for_lf = True, keyfile = False):
        '''This method is used to get a filepath, e.g. for 'Save as' '''

        if ask_for_lf is False or self.last_file is None:
            nav = self.gen_menu((
                        (1,0, 'Use the file browser (1)'),
                        (2,0, 'Type direct path (2)')))
        else:
            nav = self.gen_menu((
                    (1,0, 'Use the file browser (1)'),
                    (2,0, 'Type direct path (2)'),
                    (3,0, 'Use '+self.last_file+' (3)')))
        if nav == 2:
            while True:
                filepath = self.get_direct_filepath()
                if filepath is False:
                    return False
                elif ((filepath[-4:] != '.kdb' or isdir(filepath)) and 
                    keyfile is False):
                    self.draw_text(False,
                                   (1,0, 'Need path to a kdb-file!'),
                                   (3,0, 'Press any key'))
                    self.any_key()
                    continue
                else:
                    return filepath
        elif nav is False:
            return False
        else:
            if keyfile is True:
                filepath = self.browser(False, keyfile)
            else:
                filepath = self.browser(True)
                if filepath is False:
                    return False
                if filepath[-4:] != '.kdb':
                    filename = self.get_string('', 'Filename: ')
                    filepath += '/'+filename+'.kdb'
            return filepath

    def get_direct_filepath(self):
        '''Get a direct filepath.'''

        e = ''
        show = 0
        rem = []
        cur_dir = ''
        if self.last_file is not None:
            edit = self.last_file
        else:
            edit = ''
        while e != NL:
            if e == KEY_BACKSPACE or e == DEL and len(edit) != 0:
                edit = edit[:-1]
                show = 0
                rem = []
                cur_dir = ''
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                self.del_clipboard()
            elif e == 4:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == '':
                pass
            elif e == KEY_F5:
                return False
            elif e == KEY_RESIZE:
                self.resize_all()
            elif e == ord('~'):
                edit += expanduser('~/')
                show = 0
                rem = []
                cur_dir = ''
            elif e == ord('\t'):
                if cur_dir == '':
                    last = edit.split('/')[-1]
                    cur_dir = edit[:-len(last)]
                try:
                    dir_cont = listdir(cur_dir)
                except OSError:
                    pass
                else:
                    if len(rem) == 0:
                        for i in dir_cont:
                            if i[:len(last)] == last:
                                rem.append(i)
                    if len(rem) > 0:
                        edit = cur_dir+rem[show]
                    else:
                        edit = cur_dir+last
                    if show+1 >= len(rem):
                        show = 0
                    else:
                        show += 1
                    if isdir(edit):
                        edit += '/'
            else:
                show = 0
                rem = []
                cur_dir = ''
                edit += chr(e)

            self.draw_text(False, (1,0, 'Filepath: '+edit))
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
        return edit

    def browser(self, mode_new = False, keyfile = False):
        '''A simple file browser.

        mode_new is needed to get a filepath to a new database file.

        '''

        kdb_file = None
        if self.cur_dir[-4:] == '.kdb':
            kdb_file = self.cur_dir.split('/')[-1]
            self.cur_dir = self.cur_dir[:-len(kdb_file)-1]
            kdb_file = self.cur_dir+'/'+kdb_file

        hidden = True
        highlight = 0
        while True:
            self.draw_text(False)
            try:
                dir_cont = listdir(self.cur_dir)
            except OSError:
                self.draw_text(False,
                               (1,0, 'Was not able to read directory'),
                               (2,0, 'Press any key.'))
                self.any_key()
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
                if self.cur_dir == '': self.cur_dir = '/';
                return False
                
            rem = []
            for i in dir_cont:
                if ((not isdir(self.cur_dir+'/'+i) and not i[-4:] == '.kdb' and
                     keyfile is False) or (i[0] == '.' and hidden is True)):
                    rem.append(i)
            for i in rem:
                dir_cont.remove(i)
            
            dirs = []
            files = []
            for i in dir_cont:
                if isdir(self.cur_dir+'/'+i):
                    dirs.append(i)
                else:
                    files.append(i)
            dirs.sort()
            files.sort()

            dir_cont = []
            dir_cont.extend(dirs)
            dir_cont.extend(files)
            if not self.cur_dir == '/': dir_cont.insert(0, '..');

            self.show_dir(highlight, dir_cont)
            try:
                c = self.stdscr.getch()
            except KeyboardInterrupt:
                c = 4
            if c == KEY_DOWN or c == ord('j'):
                if highlight >= len(dir_cont)-1:
                    continue
                highlight += 1
                self.show_dir(highlight, dir_cont)
            elif c == KEY_UP or c == ord('k'):
                if highlight <= 0:
                    continue
                highlight -= 1
                self.show_dir(highlight, dir_cont)
            elif c == KEY_LEFT or c == ord('h'):
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
                if self.cur_dir == '': self.cur_dir = '/';
                highlight = 0
            elif c == NL or c == KEY_RIGHT or c == ord('l'):
                if dir_cont[highlight] == '..':
                    last = self.cur_dir.split('/')[-1]
                    self.cur_dir = self.cur_dir[:-len(last)-1]
                    if self.cur_dir == '': self.cur_dir = '/';
                    highlight = 0
                elif isdir(self.cur_dir+'/'+dir_cont[highlight]):
                    self.cur_dir = self.cur_dir+'/'+dir_cont[highlight]
                    if self.cur_dir[:2] == '//': 
                        self.cur_dir = self.cur_dir[1:]
                    highlight = 0
                else:
                    if mode_new is False:
                        ret = self.cur_dir+'/'+dir_cont[highlight]
                        if kdb_file is not None:
                            self.cur_dir = kdb_file
                        return ret
                    else:
                        ret = self.cur_dir+'/'+dir_cont[highlight]
                        if kdb_file is not None:
                            self.cur_dir = kdb_file
                        return ret
            elif c == -1:
                self.del_clipboard()
            elif c == KEY_RESIZE:
                self.resize_all()
            elif c == KEY_F1 and mode_new is True:
                noraw()
                self.stdscr.keypad(0)
                endwin()
                print('Navigate with arrow keys.')
                print('\'o\' - choose directory')
                print('\'e\' - abort')
                print('\'H\' - show/hide hidden files')
                try:
                    input('Press any key')
                except EOFError:
                    print('')
                    if not self.db is None:
                        self.db_close()
                    exit()
                self.stdscr = initscr()
                try:
                    curs_set(0)
                except:
                    print('Invisible cursor not supported')
                raw()
                noecho()
                self.stdscr.keypad(1)
                start_color()
                use_default_colors()
                init_pair(1, -1, -1)
                init_pair(2, 2, -1)
                init_pair(3, 0, 1)
                init_pair(4, 6, -1)
                init_pair(5, 0, 6)
                init_pair(6, 0, 7)
                self.stdscr.bkgd(1)
                self.ysize, self.xsize = self.stdscr.getmaxyx()

                self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                        1, 0)
                self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                        int(2*self.xsize/3), 
                                        1, int(self.xsize/3))
                self.info_win = newwin(int((self.ysize-1)/3),
                                       int(2*self.xsize/3),
                                       int(2*(self.ysize-1)/3),
                                       int(self.xsize/3))
                self.group_win.keypad(1)
                self.entry_win.keypad(1)
                self.group_win.bkgd(1)
                self.entry_win.bkgd(1)
                self.info_win.bkgd(1)
                self.stdscr.timeout(20000)
            elif c == KEY_F1:
                noraw()
                self.stdscr.keypad(0)
                endwin()
                print('Navigate with arrow keys.')
                print('\'q\' - close program')
                print('\'e\' - abort')
                print('\'H\' - show/hide hidden files')
                try:
                    input('Press any key')
                except EOFError:
                    if not self.db is None:
                        self.db_close()
                    exit()
                self.stdscr = initscr()
                try:
                    curs_set(0)
                except:
                    print('Invisible cursor not supported')
                raw()
                noecho()
                self.stdscr.keypad(1)
                start_color()
                use_default_colors()
                init_pair(1, -1, -1)
                init_pair(2, 2, -1)
                init_pair(3, 0, 1)
                init_pair(4, 6, -1)
                init_pair(5, 0, 6)
                init_pair(6, 0, 7)
                self.stdscr.bkgd(1)
                self.stdscr.timeout(20000)
                self.ysize, self.xsize = self.stdscr.getmaxyx()

                self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                        1, 0)
                self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                        int(2*self.xsize/3), 
                                        1, int(self.xsize/3))
                self.info_win = newwin(int((self.ysize-1)/3),
                                       int(2*self.xsize/3),
                                       int(2*(self.ysize-1)/3),
                                       int(self.xsize/3))
                self.group_win.keypad(1)
                self.entry_win.keypad(1)
                self.group_win.bkgd(1)
                self.entry_win.bkgd(1)
                self.info_win.bkgd(1)
                self.stdscr.timeout(20000)
            elif c == KEY_F5:
                return False
            elif c == ord('H'):
                if hidden == True:
                    hidden = False
                else:
                    hidden = True
            elif c == 4:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()
            elif c == ord('q') and mode_new is not True:
                self.del_clipboard()
                if self.db is not None:
                    self.db_close()
                self.close()
            elif c == ord('e'):
                return False
            elif c == ord('o') and mode_new is True:
                if kdb_file is not None:
                    ret = self.cur_dir
                    self.cur_dir = kdb_file
                    return ret
                else:
                    return self.cur_dir

    def show_dir(self, highlight, dir_cont):
        '''List a directory with highlighting.'''

        for i in range(len(dir_cont)):
            if i == highlight:
                if isdir(self.cur_dir+'/'+dir_cont[i]):
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i], color_pair(5))
                    except:
                        pass
                else:
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i], color_pair(3))
                    except:
                        pass
            else:
                if isdir(self.cur_dir+'/'+dir_cont[i]):
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i], color_pair(4))
                    except:
                        pass
                else:    
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i])
                    except:
                        pass
        self.stdscr.refresh()

    def open_file(self):
        while True:
            auth = self.gen_menu((
                   (1,0, 'Use a password (1)'),
                   (2,0, 'Use a keyfile (2)'),
                   (3,0, 'Use both (3)')))
            if auth is False:
                return False
            if auth == 1 or auth == 3:
                password = self.get_password('Password: ')
                if password is False:
                    continue
                if auth != 3: keyfile = None;
            if auth == 2 or auth == 3:
                # Ugly construct but works
                # "if keyfile is False" stuff is needed to implement the
                # return to previous screen stuff
                while True:
                    keyfile = self.get_filepath(False, True)
                    if keyfile is False:
                        break
                    elif not isfile(keyfile):
                        self.draw_text(False,
                                       (1,0, 'That\'s not a file'),
                                       (3,0, 'Press any key.'))
                        self.any_key()
                        continue
                    break
                if keyfile is False:
                    continue
                if auth != 3: password = None
            break
        try:
            if isfile(self.cur_dir+'.lock'):
                self.draw_text(False,
                               (1,0, 'Database seems to be opened.'
                                     ' Open file in read-only mode?'
                                     ' [(y)/n]'))
                while True:
                    try:
                        e = self.stdscr.getch()
                    except KeyboardInterrupt:
                        e = 4

                    if e == ord('n'):
                        self.db = KPDB(self.cur_dir, password, keyfile, False)
                        break
                    elif e == -1:
                        self.del_clipboard()
                    elif e == 4:
                        self.del_clipboard()
                        if self.db is not None:
                            self.db_close()
                        self.close()
                    elif e == KEY_RESIZE:
                        self.resize_all()
                    elif e == KEY_F5:
                        return False
                    else:
                        self.db = KPDB(self.cur_dir, password, keyfile, True)
                        break
            else:
                self.db = KPDB(self.cur_dir, password, keyfile, False)
            return True
        except KPError as err:
            self.draw_text(False,
                           (1,0, err.__str__()),
                           (4,0, 'Press any key.'))
            self.any_key()
            last = self.cur_dir.split('/')[-1]
            self.cur_dir = self.cur_dir[:-len(last)-1]
            return False

    def close(self):
        '''Close the program correctly.'''

        noraw()
        self.stdscr.keypad(0)
        endwin()
        exit()

    def save(self, cur_dir):
        '''Save the database. cur_dir is the current directory.'''
        self.draw_text(False,   
                       (1,0,'Do not interrupt or '
                            'your file will break!'))
        try:
            if cur_dir is False:
                self.db.save()
            else:
                self.db.save(cur_dir)
        except KPError as err:
            self.draw_text(False,
                           (1,0, err.__str__()),
                           (4,0, 'Press any key.'))
            self.any_key()
            return False

    def db_close(self):
        '''Close the database correctly.'''

        if self.db.filepath is not None:
            try:
                self.db.close()
            except KPError as err:
                self.draw_text(False,
                               (1,0, err.__str__()),
                               (4,0, 'Press any key.'))
                self.any_key()
        self.db = None

    def db_browser(self):
        '''The database browser.'''

        if self.cur_dir[-4:] == '.kdb':
            if not isdir(expanduser('~/.config')):
                mkdir(expanduser('~/.config'))
            handler = open(expanduser('~/.config/keepassc'), 'w')
            handler.write(self.cur_dir)
            handler.close()
        
        hide = True
        changed = False
        cur_win = 0
        g_highlight = 0
        e_highlight = 0
        g_offset = 0
        e_offset = 0
        self.cur_root = self.db._root_group
        groups = sorted(self.cur_root.children,
                        key = lambda group: group.title.lower())
        entries = []
        if groups and groups[g_highlight].entries:
            entries = sorted(groups[g_highlight].entries,
                             key = lambda entry: entry.title.lower())
        else:
            entries = []

        self.show_groups(g_highlight, groups, cur_win, g_offset, 
                         changed)
        self.show_entries(e_highlight, entries, cur_win, e_offset,
                          hide)

        while True:
            try:
                c = self.stdscr.getch()
            except KeyboardInterrupt:
                c = 4
            
            if c == ord('\t'):
                if cur_win == 0:
                    c = KEY_RIGHT
                else:
                    c = KEY_LEFT

            if c == KEY_F1:
                noraw()
                self.stdscr.keypad(0)
                endwin()
                print('\'e\' - go to main menu')
                print('\'q\' - close program')
                print('\'x\' - save db and close program')
                print('\'s\' - save db')
                print('\'S\' - save db with alternative filepath')
                print('\'c\' - copy password of current entry')
                print('\'b\' - copy username of current entry')
                print('\'H\' - show password of current entry')
                print('\'o\' - open URL of entry in standard webbrowser')
                print('\'P\' - edit db password')
                print('\'g\' - create group')
                print('\'G\' - create subgroup')
                print('\'y\' - create entry')
                print('\'d\' - delete group or entry')
                print('\'t\' - edit title of selected group or entry')
                print('\'u\' - edit username')
                print('\'p\' - edit password')
                print('\'U\' - edit URL')
                print('\'C\' - edit comment')
                print('\'E\' - edit expiration date')
                print('\'f\' - find entry by title')
                print('\'L\' - lock db')
                print('Navigate with arrow keys or h/j/k/l like in vim')
                print('Type \'F5\' in a dialog to return to the previous one')
                print('Type \'return\' to enter subgroups')
                print('Type \'backspace\' to go back')
                try:
                    input('Press any key.')
                except EOFError:
                    if not self.db is None:
                        self.db_close()
                    exit()
                self.stdscr = initscr()
                try:
                    curs_set(0)
                except:
                    print('Invisible cursor not supported')
                raw()
                noecho()
                self.stdscr.keypad(1)
                start_color()
                use_default_colors()
                init_pair(1, -1, -1)
                init_pair(2, 2, -1)
                init_pair(3, 0, 1)
                init_pair(4, 6, -1)
                init_pair(5, 0, 6)
                init_pair(6, 0, 7)
                self.stdscr.bkgd(1)
                self.ysize, self.xsize = self.stdscr.getmaxyx()

                self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                        1, 0)
                self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                        int(2*self.xsize/3), 
                                        1, int(self.xsize/3))
                self.info_win = newwin(int((self.ysize-1)/3)-1,
                                       int(2*self.xsize/3),
                                       int(2*(self.ysize-1)/3),
                                       int(self.xsize/3))
                self.group_win.keypad(1)
                self.entry_win.keypad(1)
                self.group_win.bkgd(1)
                self.entry_win.bkgd(1)
                self.info_win.bkgd(1)
                self.stdscr.timeout(20000)

                self.draw_text(changed)
                self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                 changed)
                self.show_entries(e_highlight, entries, cur_win, e_offset,
                                  hide)
            # File operations
            elif c == ord('e'):
                if changed is True:
                    self.draw_text(changed, 
                                   (1,0, 'File has changed. Save? [(y)/n]'))
                    no_exit = False
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == 4:
                            self.del_clipboard()
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            self.del_clipboard()
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        elif e == KEY_F5:
                            no_exit = True
                            break
                        elif e == ord('n'):
                            break
                        else:
                            if self.db.filepath is None:
                                filepath = self.get_filepath()
                                if filepath is not False:
                                    self.cur_dir = filepath
                                    self.save(self.cur_dir)
                            else:
                                self.save(False)
                            break
                    if no_exit is True:
                        self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                         changed)
                        self.show_entries(e_highlight, entries, cur_win,
                                          e_offset, hide)
                        continue
                        
                self.del_clipboard()
                self.db_close()
                self.group_win.clear()
                self.entry_win.clear()
                self.info_win.clear()
                self.group_win.noutrefresh()
                self.entry_win.noutrefresh()
                self.info_win.noutrefresh()
                doupdate()
                break
            elif c == ord('q') or c == 4:
                self.del_clipboard()
                if changed is True:
                    self.draw_text(changed, (1,0, 'File has changed. Save? [(y)/n]'))
                    no_exit = False
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == 4:
                            self.del_clipboard()
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            self.del_clipboard()
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        elif e == ord('n'):
                            break
                        elif e == KEY_F5:
                            no_exit = True
                            break
                        else:
                            if self.db.filepath is None:
                                filepath = self.get_filepath()
                                if filepath is not False:
                                    self.cur_dir = filepath
                                    self.save(self.cur_dir)
                            else:
                                self.save(False)
                            break
                    if no_exit is True:
                        self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                         changed)
                        self.show_entries(e_highlight, entries, cur_win,
                                          e_offset, hide)
                        continue
                self.db_close()
                self.close()
            elif c == ord('c'):
                if entries:
                    entry = entries[e_highlight]
                    if entry.password is not None:
                        Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                        Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        p = entry.password
                        (Popen(['xsel', '-pi'], stdin = PIPE, stderr = PIPE,
                         stdout = PIPE).communicate(p.encode()))
                        (Popen(['xsel', '-bi'], stdin = PIPE, stderr = PIPE,
                         stdout = PIPE).communicate(p.encode()))
                        self.cb = entry.password
                        self.del_cb = True
            elif c == ord('b'):
                if entries:
                    entry = entries[e_highlight]
                    if entry.username is not None:
                        Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                        Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        p = entry.username
                        (Popen(['xsel', '-pi'], stdin = PIPE, stderr = PIPE,
                         stdout = PIPE).communicate(p.encode()))
                        (Popen(['xsel', '-bi'], stdin = PIPE, stderr = PIPE,
                         stdout = PIPE).communicate(p.encode()))
                        self.cb = entry.username
                        self.del_cb = True
            elif c == ord('o'):
                if entries:
                    entry = entries[e_highlight]
                    url = entry.url
                    if url != '':
                        if url[:7] != 'http://' and url[:8] != 'https://':
                            url = 'http://'+url
                        webbrowser.open(url)
            elif c == -1:
                self.del_clipboard()
            elif c == ord('s'):
                if self.db.filepath is None:
                    filepath = self.get_filepath()
                    if filepath is not False:
                        self.cur_dir = filepath
                if self.save(self.cur_dir) is not False:
                    changed = False
                self.show_groups(g_highlight, groups, cur_win, g_offset, changed)
                self.show_entries(e_highlight, entries, cur_win, e_offset,
                                  hide)
            elif c == ord('S'):
                filepath = self.get_filepath(False)
                if filepath is not False:
                    if self.db.filepath is None:
                        self.cur_dir = filepath
                    if isfile(filepath):
                        self.draw_text(changed, (1,0, 
                                        'File exists. Overwrite? [y/(n)]'))
                        while True:
                            try:
                                c = self.stdscr.getch()
                            except KeyboardInterrupt:
                                c = 4
                            if c == ord('y'):
                                if self.save(filepath) is not False:
                                    changed = False
                                break
                            elif c == 4:
                                self.del_clipboard()
                                if self.db is not None:
                                    self.db_close()
                                self.close()
                            elif c == -1:
                                self.del_clipboard()
                            elif c == KEY_RESIZE:
                                self.resize_all()
                            else:
                                break
                    else:
                        if self.save(filepath) is not False:
                            changed = False
                self.show_groups(g_highlight, groups, cur_win, g_offset, changed)
                self.show_entries(e_highlight, entries, cur_win, e_offset,
                                  hide)
                changed = False
            elif c == ord('x'):
                self.del_clipboard()
                if self.db.filepath is None:
                    filepath = self.get_filepath()
                    if filepath is not False:
                        self.cur_dir = filepath
                        if self.save(self.cur_dir) is not False:
                            self.db_close()
                            self.close()
                elif self.save(self.cur_dir) is not False:
                    self.db_close()
                    self.close()
                self.show_groups(g_highlight, groups, cur_win, g_offset, changed)
                self.show_entries(e_highlight, entries, cur_win, e_offset,
                                  hide)
            elif c == ord('L'):
                if changed is True:
                    self.draw_text(changed,
                                   (1,0, 'File has changed. Save? [(y)/n]'))
                    no_lock = False
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == 4:
                            self.del_clipboard()
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            self.del_clipboard()
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        elif e == KEY_F5:
                            no_lock = True
                            break
                        elif e == ord('n'):
                            break
                        else:
                            if self.db.filepath is None:
                                filepath = self.get_filepath()
                                if filepath is not False:
                                    self.cur_dir = filepath
                                    self.save(self.cur_dir)
                                    changed = False
                            else:
                                self.save(False)
                                changed = False
                            break
                if no_lock is True:
                    self.show_groups(g_highlight, groups, cur_win, g_offset,
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
                    continue
                self.del_clipboard()
                if self.db.filepath is None:
                    self.draw_text(changed,
                                   (1,0, 'Can only lock an existing db!'),
                                   (4,0, 'Press any key.'))
                    self.any_key()
                    continue
                self.db.lock()
                while True:
                    auth = self.gen_menu((
                           (1,0, 'Use a password (1)'),
                           (2,0, 'Use a keyfile (2)'),
                           (3,0, 'Use both (3)')))
                    if auth is False:
                        continue
                    if auth == 1 or auth == 3:
                        password = self.get_password('Password: ')
                        if password is False:
                            continue
                        if auth != 3: keyfile = None;
                    if auth == 2 or auth == 3:
                        while True:
                            keyfile = self.get_direct_filepath()
                            if keyfile is False:
                                break
                            elif not isfile(keyfile):
                                self.draw_text(changed,
                                               (1,0, 'That\'s not a file'),
                                               (3,0, 'Press any key.'))
                                self.any_key()
                                continue
                            break
                        if keyfile is False:
                            continue
                        if auth != 3: password = None
                    try:
                        self.db.unlock(password, keyfile)
                    except KPError as err:
                        self.draw_text(changed,
                                       (1,0, err.__str__()),
                                       (4,0, 'Press any key.'))
                        self.any_key()
                    else:
                        self.cur_root = self.db._root_group
                        groups = sorted(self.cur_root.children,
                                        key = lambda group: group.title.lower())
                        if groups and groups[g_highlight].entries:
                            entries = sorted(groups[g_highlight].entries,
                                             key = lambda entry: 
                                             entry.title.lower())
                        else:
                            entries = []
                        self.show_groups(g_highlight, groups, cur_win, g_offset,
                                         changed)
                        self.show_entries(e_highlight, entries, cur_win,
                                          e_offset, hide)
                        break
            # DB editing
            elif c == ord('P'):
                while True:
                    auth = self.gen_menu((
                           (1,0, 'Use a password (1)'),
                           (2,0, 'Use a keyfile (2)'),
                           (3,0, 'Use both (3)')))
                    if auth == 2 or auth == 3:
                        while True:
                            filepath = self.get_filepath(False, True)
                            if not isfile(filepath):
                                self.draw_text(changed,
                                               (1,0,"That's not a file!"),
                                               (3,0,'Press any key.'))
                                self.any_key()
                                continue
                            break
                        if filepath is False:
                            continue
                        self.db.keyfile = ret
                        changed = True
                        if auth != 3: self.db.password = None;
                    if auth == 1 or auth == 3:
                        password = self.get_password('New Password: ')
                        if password is False:
                            continue
                        confirm = self.get_password('Confirm: ')
                        if confirm is False:
                            continue
                        if password == confirm:
                            self.db.password = password
                            changed = True
                        else:
                            try:
                                self.stdscr.addstr(3,0, 'Passwords didn\'t match. '
                                                        'Press any key.')
                            except:
                                pass
                            self.any_key()
                        if auth != 3: self.db.keyfile = None;
                    break
                self.show_groups(g_highlight, groups, cur_win, g_offset, changed)
                self.show_entries(e_highlight, entries, cur_win, e_offset,
                                  hide)
            elif c == ord('g'):
                edit = self.get_string('', 'Title: ')
                if edit is not False:
                    if groups:
                        old_group = groups[g_highlight]
                    else:
                        old_group = None

                    try: 
                        if self.cur_root is self.db._root_group:
                            self.db.create_group(edit)
                        else:
                            self.db.create_group(edit, self.cur_root)
                    except KPError as err:
                        self.draw_text(changed,
                                       (1,0, err.__str__()),
                                       (4,0, 'Press any key.'))
                        self.any_key()
                    else:
                        changed = True
                    groups = sorted(self.cur_root.children,
                                    key = lambda group: group.title.lower())
                    if groups and groups[g_highlight].entries:
                        entries = sorted(groups[g_highlight].entries,
                                         key = lambda entry: entry.title.lower())
                    else:
                        entries = []
                    if (groups and (groups[g_highlight] is not old_group) and
                        old_group is not None):
                        g_highlight = groups.index(old_group)
                self.show_groups(g_highlight, groups, cur_win, g_offset,
                                 changed)
                self.show_entries(e_highlight, entries, cur_win, e_offset,
                                  hide)
            elif c == ord('G'):
                if groups:
                    edit = self.get_string('', 'Title: ')
                    if edit is not False:
                        try: 
                            self.db.create_group(edit, groups[g_highlight])
                        except KPError as err:
                            self.draw_text(changed,
                                           (1,0, err.__str__()),
                                           (4,0, 'Press any key.'))
                            self.any_key()
                        else:
                            changed = True
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            elif c == ord('y'):
                if groups:
                    if entries:
                        old_entry = entries[e_highlight]
                    else:
                        old_entry = None
                    self.draw_text(changed,
                                   (1,0, 'At least one of the following attributes '
                                    'must be given. Press any key'))
                    self.any_key()

                    pass_title = False
                    pass_url = False
                    pass_username = False
                    pass_password = False
                    pass_confirm = False
                    pass_comment = False
                    goto_last = False
                    while True:
                        if pass_title is False:
                            title = self.get_string('', 'Title: ')
                        if title is False:
                            break
                        pass_title = True

                        if pass_url is False:
                            url = self.get_string('', 'URL: ')
                        if url is False:
                            pass_title = False
                            continue
                        pass_url = True

                        if pass_username is False:
                            username = self.get_string('', 'Username: ')
                        if username is False:
                            pass_url = False
                            continue
                        pass_username = True

                        if pass_password is False:
                            nav = self.gen_menu(((1,0, 'Use password generator (1)'),
                                                 (2,0, 'Type password by hand (2)')))
                            if nav == 1:
                                password = self.gen_pass()
                                if password is False:
                                    continue
                            elif nav == 2:
                                while True:
                                    password = self.get_password('Password: ')
                                    if password is False:
                                        break
                                    confirm = self.get_password('Confirm: ')
                                    if confirm is False:
                                        continue
                                    
                                    if password != confirm:
                                        try:
                                            self.stdscr.addstr(3,0, 'Passwords didn\'t match. '
                                                                    'Press any key.')
                                        except:
                                            pass
                                        self.any_key()
                                    else:
                                        break
                                if password is False:
                                    continue
                        if nav is False:
                            pass_username = False
                            continue
                        pass_password = True

                        if pass_comment is False:
                            comment = self.get_string('', 'Comment: ')
                        if comment is False:
                            pass_password = False
                            continue
                        pass_comment = True
                        
                        self.draw_text(changed,
                                       (1,0, 'Set expiration date? [y/(n)]'))
                        while True:
                            try:
                                e = self.stdscr.getch()
                            except KeyboardInterrupt:
                                e = 4

                            if e == ord('y'):
                                date = self.get_exp_date()
                                break
                            elif e == 4:
                                self.del_clipboard()
                                if self.db is not None:
                                    self.db_close()
                                self.close()
                            elif e == -1:
                                self.del_clipboard()
                            elif e == KEY_RESIZE:
                                self.resize_all()
                            elif e == KEY_F5:
                                pass_comment = False
                                goto_last = True
                                break
                            else:
                                date = (2999,12,28)
                                break
                        if goto_last is True:
                            goto_last = False
                            continue
                        if date is False:
                            pass_comment = False
                            continue
                        try:
                            groups[g_highlight].create_entry(title, 1, url,
                                                             username, password,
                                                             comment, date[0],date[1],date[2])
                            changed = True
                        except KPError as err:
                            self.draw_text(changed,
                                           (1,0, err.__str__()),
                                           (4,0, 'Press any key.'))
                            self.any_key()
                        groups = sorted(self.cur_root.children,
                                        key = lambda group: group.title.lower())
                        entries = sorted(groups[g_highlight].entries,
                                         key = lambda entry: entry.title.lower())
                        if (entries and entries[e_highlight] is not old_entry and
                            old_entry is not None):
                            e_highlight = entries.index(old_entry)
                        break
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            elif c == ord('d'):
                if cur_win == 0 and groups:
                    title = groups[g_highlight].title
                    self.draw_text(changed,
                                   (1,0, 'Really delete group '+title+'? '
                                         '[y/(n)]'))
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == ord('y'):
                            try:
                                groups[g_highlight].remove_group()
                            except KPError as err:
                                self.draw_text(changed,
                                               (1,0, err.__str__()),
                                               (4,0, 'Press any key.'))
                                self.any_key()
                            else:
                                if (not groups and
                                    self.cur_root is not self.db._root_group):
                                    self.cur_root = self.cur_root.parent
                                changed = True

                                if (g_highlight >= len(groups) and 
                                    g_highlight != 0):
                                    g_highlight -= 1
                                e_highlight = 0
                            finally:
                                break
                        elif e == 4:
                            self.del_clipboard()
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            self.del_clipboard()
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        else:
                            break
                    groups = sorted(self.cur_root.children,
                                    key = lambda group: group.title.lower())
                    if groups and groups[g_highlight].entries:
                        entries = sorted(groups[g_highlight].entries,
                                         key = lambda entry: 
                                         entry.title.lower())
                    else:
                        entries = []
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
                elif cur_win == 1 and entries:
                    title = entries[e_highlight].title
                    self.draw_text(changed,
                                   (1,0, 
                                    'Really delete entry '+title+'? [y/(n)]'))
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == ord('y'):
                            try:
                                entries[e_highlight].remove_entry()
                            except KPError as err:
                                self.draw_text(changed,
                                               (1,0, err.__str__()),
                                               (4,0, 'Press any key.'))
                                self.any_key()
                            else:
                                changed = True
                                if not entries:
                                    cur_win = 0
                                if (e_highlight >= len(entries) and
                                    e_highlight != 0):
                                    e_highlight -= 1
                            finally:
                                break
                        elif e == 4:
                            self.del_clipboard()
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            self.del_clipboard()
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        else:
                            break
                    if groups and groups[g_highlight].entries:
                        entries = sorted(groups[g_highlight].entries,
                                         key = lambda entry: entry.title.lower())
                    else:
                        entries = []
                        cur_win = 0
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            elif c == ord('f'):
                if self.db._entries:
                    title = self.get_string('', 'Title: ')
                    if title is not False:
                        for i in self.db.groups:
                            if i.id_ == 0:
                                i.parent.children.remove(i)
                                self.db.groups.remove(i)
                                break
                        self.db.create_group('Results')
                        self.db.groups[-1].id_ = 0
                        for i in self.db._entries:
                            if title.lower() in i.title.lower():
                                self.db.groups[-1].entries.append(i)
                                cur_win = 1
                        self.cur_root = self.db._root_group
                        groups = sorted(self.cur_root.children,
                                        key = lambda group: group.title.lower())
                        for i in groups:
                            if i.id_ == 0:
                                groups.remove(i)
                                groups.append(i)
                        g_highlight = len(groups)-1
                        if groups and groups[-1].entries:
                            entries = sorted(groups[-1].entries,
                                             key = lambda entry: entry.title.lower())
                        else:
                            entries = []
                        e_highlight = 0
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win, 
                                      e_offset, hide)
                
            elif (c == ord('t') or c == ord('u') or c == ord('U') or 
                  c == ord('C')):
                if groups:
                    if not entries and cur_win == 1:
                        continue
                    if c == ord('t'):
                        std = 'Title: '
                        if cur_win == 0:
                            edit= groups[g_highlight].title
                        elif cur_win == 1:
                            edit = entries[e_highlight].title
                    elif c == ord('u') and entries:
                        std = 'Username: '
                        edit = entries[e_highlight].username
                    elif c == ord('U') and entries:
                        std = 'URL: '
                        edit = entries[e_highlight].url
                    elif c == ord('C') and entries:
                        std = 'Comment: '
                        edit = entries[e_highlight].comment
                    else:
                        continue
                    edit = self.get_string(edit, std)
                    changed = True

                    if edit is not False:
                        if c == ord('t'):
                            if cur_win == 0:
                                groups[g_highlight].set_title(edit)
                            elif cur_win == 1:
                                entries[e_highlight].set_title(edit)
                        elif c == ord('u'):
                            entries[e_highlight].set_username(edit)
                        elif c == ord('U'):
                            entries[e_highlight].set_url(edit)
                        elif c == ord('C'):
                            entries[e_highlight].set_comment(edit)
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            elif c == ord('p'):
                if entries:
                    nav = self.gen_menu(((1,0, 'Use password generator (1)'),
                                         (2,0, 'Type password by hand (2)')))
                    if nav == 1:
                        password = self.gen_pass()
                        entries[e_highlight].set_password(password)
                        changed = True
                    elif nav == 2:
                        while True:
                            password = self.get_password('Password: ')
                            if password is False:
                                break
                            confirm = self.get_password('Confirm: ')
                            if confirm is False:
                                continue
                            
                            if password == confirm:
                                entries[e_highlight].set_password(password)
                                changed = True
                                break
                            else:
                                try:
                                    self.stdscr.addstr(3,0, 'Passwords didn\'t match. '
                                                            'Press any key.')
                                except:
                                    pass
                                self.any_key()
                                break
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            elif c == ord('E'):
                if entries:
                    exp = entries[e_highlight].expire.timetuple()
                    date = self.get_exp_date(exp[0], exp[1], exp[2])

                    if date is not False:
                        entries[e_highlight].set_expire(date[0],date[1],date[2], 
                                                        exp[3], exp[4], exp[5])
                        changed = True
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            # Navigation
            elif c == ord('H'):
                if hide is True:
                    hide = False
                else:
                    hide = True
                self.show_entries(e_highlight, entries, cur_win, e_offset,
                                  hide)
            elif c == KEY_DOWN or c == ord('j'):
                if cur_win == 0:
                    if g_highlight >= len(groups)-1:
                        continue
                    ysize = self.group_win.getmaxyx()[0]
                    if (g_highlight >= ysize-4 and 
                        not g_offset >= len(groups)-ysize+4):
                        g_offset += 1
                    g_highlight += 1
                    e_offset = 0
                    e_highlight = 0
                    if groups and groups[g_highlight].entries:
                        entries = sorted(groups[g_highlight].entries,
                                         key = lambda entry: 
                                         entry.title.lower())
                    else:
                        entries = []
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
                elif cur_win == 1:
                    if e_highlight >= len(entries)-1:
                        continue
                    ysize = self.entry_win.getmaxyx()[0]
                    if (e_highlight >= ysize-4 and 
                        not e_offset >= len(entries)-ysize+3):
                        e_offset += 1
                    e_highlight += 1
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            elif c == KEY_UP or c == ord('k'):
                if cur_win == 0:
                    if g_highlight <= 0:
                        continue
                    ysize = self.group_win.getmaxyx()[0]
                    if (g_highlight <= len(self.cur_root.children)-ysize+3 and 
                        not g_offset <= 0):
                        g_offset -= 1
                    g_highlight -= 1
                    e_offset = 0
                    e_highlight = 0
                    if groups and groups[g_highlight].entries:
                        entries = sorted(groups[g_highlight].entries,
                                         key = lambda entry: 
                                         entry.title.lower())
                    else:
                        entries = []
                    self.show_groups(g_highlight, groups, cur_win, g_offset,
                                      changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
                elif cur_win == 1:
                    if e_highlight <= 0:
                        continue
                    ysize = self.entry_win.getmaxyx()[0]
                    if e_highlight <= len(entries)-ysize+3 and \
                        not e_offset <= 0:
                        e_offset -= 1
                    e_highlight -= 1
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            elif c == KEY_LEFT or c == ord('h'):
                cur_win = 0
                self.show_groups(g_highlight, groups, cur_win, g_offset, changed)
                self.show_entries(e_highlight, entries, cur_win, e_offset,
                                  hide)
            elif c == KEY_RIGHT or c == ord('l'):
                if entries:
                    cur_win = 1
                    self.show_groups(g_highlight, groups, cur_win, g_offset, 
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            elif c == KEY_RESIZE:
                self.resize_all()
                self.show_groups(g_highlight, groups, cur_win, g_offset, changed)
                self.show_entries(e_highlight, entries, cur_win, e_offset,
                                  hide)
            elif c == NL:
                if groups and groups[g_highlight].children:
                    g_highlight = 0
                    e_highlight = 0
                    cur_win = 0
                    self.cur_root = groups[g_highlight]
                    groups = sorted(self.cur_root.children,
                                    key = lambda group: group.title.lower())
                    if groups and groups[g_highlight].entries:
                        entries = sorted(groups[g_highlight].entries,
                                         key = lambda entry: entry.title.lower(
                                         ))
                    else:
                        entries = []
                    self.show_groups(g_highlight, groups, cur_win, g_offset,
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
            elif c == KEY_BACKSPACE or c == DEL:
                if not self.cur_root is self.db._root_group:
                    g_highlight = 0
                    e_highlight = 0
                    cur_win = 0
                    self.cur_root = self.cur_root.parent
                    groups = sorted(self.cur_root.children,
                                    key = lambda group: group.title.lower())
                    for i in groups:
                        if i.id_ == 0:
                            groups.remove(i)
                            groups.append(i)
                    if groups and groups[g_highlight].entries:
                        entries = sorted(groups[g_highlight].entries,
                                         key = lambda entry: entry.title.lower(
                                         ))
                    else:
                        entries = []
                    self.show_groups(g_highlight, groups, cur_win, g_offset,
                                     changed)
                    self.show_entries(e_highlight, entries, cur_win,
                                      e_offset, hide)
        
    def show_groups(self, highlight, groups, cur_win, offset, changed):
        self.draw_text(changed)
        self.group_win.clear()
        parent = self.cur_root
        if parent is self.db._root_group:
            root_title = 'Parent: _ROOT_'
        else:
            root_title = 'Parent: '+parent.title
        if cur_win == 0:
            h_color = 5
            n_color = 4
        else:
            h_color = 6
            n_color = 1

        try:
            ysize = self.group_win.getmaxyx()[0]
            self.group_win.addstr(0,0, root_title,
                                   color_pair(n_color))
            if groups:
                if len(groups) <= ysize-3:
                    num = len(groups)
                else:
                    num = ysize-3
                    
                for i in range(num):
                    if highlight == i+offset:
                        if groups[i].children:
                            title = '+'+groups[i+offset].title
                        else:
                            title = ' '+groups[i+offset].title
                        self.group_win.addstr(i+1, 0, title,
                                               color_pair(h_color))
                    else:
                        if groups[i].children:
                            title = '+'+groups[i+offset].title
                        else:
                            title = ' '+groups[i+offset].title
                        self.group_win.addstr(i+1, 0, title,
                                              color_pair(n_color))
                x_of_n = str(highlight+1)+' of '+str(len(groups))
                self.group_win.addstr(ysize-2,0, x_of_n)
        except:
            pass
        finally:
            self.group_win.refresh()

    def show_entries(self, e_highlight, entries, cur_win, offset,
                     hide):
        self.info_win.clear()
        try:
            self.entry_win.clear()
            if entries:
                if cur_win == 1:
                    h_color = 5
                    n_color = 4
                else:
                    h_color = 6
                    n_color = 1

                ysize = self.entry_win.getmaxyx()[0]
                if len(entries) <= ysize-3:
                    num = len(entries)
                else:
                    num = ysize-3
                    
                for i in range(num):
                    title = entries[i+offset].title
                    if e_highlight == i+offset:
                        self.entry_win.addstr(i, 2,  title,
                                               color_pair(h_color))
                    else:
                        self.entry_win.addstr(i, 2, title,
                                               color_pair(n_color))
                self.entry_win.addstr(ysize-2, 2, (str(e_highlight+1)+
                                                    ' of '+
                                                    str(len(entries))))
        except:
            pass
        finally:
            self.entry_win.noutrefresh()

        try:
            if entries:
                entry = entries[e_highlight]
                if entry.title is None:
                    title = ""
                else:
                    title = entry.title
                if entry.group.title is None:
                    group_title = ""
                else:
                    group_title = entry.group.title
                if entry.username is None:
                    username = ""
                else:
                    username = entry.username
                if entry.password is None or hide is True:
                    password = ""
                else:
                    password = entry.password
                if entry.url is None:
                    url = ""
                else:
                    url = entry.url
                if entry.creation is None:
                    creation = ""
                else:
                    creation = entry.creation.__str__()[:10]
                if entry.last_access is None:
                    last_access = ""
                else:
                    last_access = entry.last_access.__str__()[:10]
                if entry.last_mod is None:
                    last_mod = ""
                else:
                    last_mod = entry.last_mod.__str__()[:10]
                if entry.expire is None:
                    expire = ""
                else:
                    if entry.expire.__str__()[:19] == '2999-12-28 23:59:59':
                        expire = "Expires: Never"
                    else:
                        expire = "Expires: "+entry.expire.__str__()[:10]
                if entry.comment is None:
                    comment = ""
                else:
                    comment = entry.comment

                self.info_win.addstr(2,0, title, A_BOLD)
                self.info_win.addstr(3,0, "Group: "+group_title)
                self.info_win.addstr(4,0, "Username: "+username)
                self.info_win.addstr(5,0, "Password: "+password)
                self.info_win.addstr(6,0, "URL: "+url)
                self.info_win.addstr(7,0, "Creation: "+creation)
                self.info_win.addstr(8,0, "Access: "+last_access)
                self.info_win.addstr(9,0, "Modification: "+last_mod)
                self.info_win.addstr(10,0, expire)
                if date.today() > entry.expire.date():
                    self.info_win.addstr(10,22, ' (expired)')
                self.info_win.addstr(11,0, "Comment: "+comment)
        except:
            pass
        finally:
            self.info_win.noutrefresh()
        doupdate()

if __name__ == '__main__':
    parser = OptionParser('keepassc [options] [path to .kdb-file] [path to '
                          'key-file]\npath to keyfile is only required if '
                          'you use -e or --entry')
    parser.add_option('--asroot', action='store_true', dest='asroot', 
                      default=False, help='parse option to execute keepassc '
                                          'as root user')
    parser.add_option('-e', '--entry', dest='entry', default='', help='print '
                      'entry with parsed title\nYou will see a password '
                      'prompt; leave it blank if you only want to use a '
                      'key-file\nJust type a part of the entry title '
                      'lower-case, it\'s case-insensitive and will search for '
                      'matching string parts\n\n'
                      'WARNING: Your passwords will be displayed directly on '
                      'your command line!')
    (options, args) = parser.parse_args()

    if geteuid() == 0 and options.asroot is False:
        print('If you really want to execute this program as root user type '
              '\'keepassc --asroot\'')
        print('Warning: This will annul a security concept of keepassc')
    elif options.entry != '' and len(args) == 0:
        print('Need a file path to print entry information')
    else:
        if options.entry != '':
            password = getpass()
            if password == '':
                password = None
            if len(args) > 2:
                keyfile = args[-1]
            else:
                keyfile = None
            try:
                db = KPDB(args[0], password, keyfile)
            except KPError as err:
                print(err)
                exit()
            for i in db._entries:
                if options.entry.lower() in i.title.lower():
                    print('Title: '+i.title)
                    if i.url is not None: stdout.write('URL: '+i.url+'\n')
                    if i.username is not None: stdout.write('Username: '+
                                                            i.username+'\n')
                    if i.password is not None: stdout.write('Password: '+
                                                            i.password+'\n')
                    if i.creation is not None: stdout.write('Creation: '+
                                                     i.creation.__str__()+'\n')
                    if i.last_access is not None: stdout.write('Access: '+
                                                        i.last_access.__str__()
                                                        +'\n')
                    if i.last_mod is not None: stdout.write('Modification: '+
                                                     i.last_mod.__str__()+'\n')
                    if i.expire is not None: stdout.write('Expiration: '+
                                                   i.expire.__str__()+'\n')
                    if i.comment is not None: stdout.write('Comment: '+
                                                           i.comment+'\n\n')
                    stdout.flush()
        elif len(args) > 0 and args[0][-4:] == '.kdb':
            filepath = realpath(expanduser(args[0]))
            app = App()
            wrapper(app.main_loop(filepath))
        else:
            app = App()
            wrapper(app.main_loop())

