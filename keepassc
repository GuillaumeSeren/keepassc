#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Copyright (C) 2012 Karsten-Kai KÃ¶nig <kkoenig@posteo.de>

This file is part of keepassc.

keepassc is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or at your 
option) any later version.

keepassc is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with keepassc.  If not, see <http://www.gnu.org/licenses/>.
'''

import webbrowser
from curses import *
from _curses import error
from curses.ascii import NL, DEL
from datetime import date
from os import chdir, getcwd, geteuid, listdir, mkdir
from os.path import isdir, isfile, expanduser, realpath
from pwd import getpwuid
from socket import gethostname
from subprocess import Popen, PIPE
from sys import exit, argv

from kppy import *

__doc__ = '''This program gives you access to your KeePass 1.x or 
          KeePassX databases through a nice curses interface.

          It is completely controllable with the keyboard.

         '''

class App(object):
    '''This class represents the whole application.'''
    def __init__(self):
        '''The __init__-method. 

        It just initializes some variables and settings and changes
        the working directory to /var/empty to prevent coredumps as
        normal user.

        '''

        self.stdscr = initscr()
        self.ysize, self.xsize = self.stdscr.getmaxyx()
        self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                1, 0)
        self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                int(2*self.xsize/3), 
                                1, int(self.xsize/3))
        self.info_win = newwin(int((self.ysize-1)/3),
                               int(2*self.xsize/3),
                               int(2*(self.ysize-1)/3),
                               int(self.xsize/3))
        try:
            curs_set(0)
        except:
            print('Invisible cursor not supported')
        cbreak()
        noecho()
        self.stdscr.keypad(1)
        self.group_win.keypad(1)
        self.entry_win.keypad(1)
        start_color()
        use_default_colors()
        init_pair(1, -1, -1)
        init_pair(2, 2, -1)
        init_pair(3, 0, 1)
        init_pair(4, 6, -1)
        init_pair(5, 0, 6)
        init_pair(6, 0, 7)
        self.stdscr.bkgd(1)
        self.group_win.bkgd(1)
        self.entry_win.bkgd(1)
        self.info_win.bkgd(1)
        self.stdscr.timeout(20000)

        try:
            handler = open(expanduser('~/.config/keepassc'), 'r')
            self.last_file = handler.readline()
            handler.close()
        except:
            self.last_file = None

        self.loginname = getpwuid(geteuid())[0]
        self.hostname = gethostname()
        self.cur_dir = getcwd()
        self.db = None

        chdir('/var/empty')
    
    def resize_all(self):
        self.ysize, self.xsize = self.stdscr.getmaxyx()
        self.group_win.resize(self.ysize-1, int(self.xsize/3))
        self.entry_win.resize(int(2*(self.ysize-1)/3),
                              int(2*self.xsize/3))
        self.info_win.resize(int((self.ysize-1)/3),
                             int(self.xsize/3)-2)
        self.group_win.mvwin(1,0)
        self.entry_win.mvwin(1, int(self.xsize/3))
        self.info_win.mvwin(int(2*(self.ysize-1)/3),
                            int(self.xsize/3))

    def any_key(self):
        '''If any key is needed.'''

        while True:
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
            if e == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif e == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            else:
                break

    def draw_text(self, *misc):
        '''This method is a wrapper to display some text on stdscr.

        misc is a list that should consist of 3-tuples which holds
        text to display.
        (1st element: y-coordinate, 2nd: x-coordinate, 3rd: text)
        '''

        try:
            self.stdscr.clear()
            self.stdscr.addstr(0,0, self.loginname+'@'+self.hostname+':', 
                               color_pair(2))
            self.stdscr.addstr(0, len(self.loginname+'@'+self.hostname+':'),
                               self.cur_dir)
            for i,j,k in misc:
                self.stdscr.addstr(i,j, k)
        except:
            pass
        finally:
            self.stdscr.refresh()

    def get_string(self, edit = '', std = ''):
        '''This method is used to get user input.

        edit is the string to edit and std is text
        which should be displayed in front of edit.
        (std edit)

        '''

        offset = len(std)
        e = ''
        while e != NL:
            if e == KEY_BACKSPACE or e == DEL and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif e == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == '':
                pass
            elif e == KEY_RESIZE:
                self.resize_all()
            else:
                edit += chr(e)

            self.draw_text((1,0,std),(1,offset, edit))
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
        return edit

    def get_password(self, std, needed = True):
        '''This method is used to get a password.

        The pasword will not be displayed during typing.

        std is a string that should be displayed. If needed is True it
        is not possible to return an emptry string.

        '''

        self.draw_text((1,0, std))

        password = ''
        e = ''
        while e != NL or (len(password) == 0 and needed is True):
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
            if e == KEY_BACKSPACE or e == DEL and len(password) != 0:
                password = password[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == '':
                pass
            elif e == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif e == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.ysize, self.xsize = self.stdscr.getmaxyx()
                self.group_win.resize(self.ysize-1, int(self.xsize/3))
                self.entry_win.resize(int(2*(self.ysize-1)/3),
                                      int(2*self.xsize/3))
                self.info_win.resize(int((self.ysize-1)/3),
                                     int(self.xsize/3)-2)
                self.group_win.mvwin(1,0)
                self.entry_win.mvwin(1, int(self.ysize/3))
                self.info_win.mvwin(int(2*(self.ysize-1)/3),
                                    int(self.ysize/3))
            else:
                password += chr(e)
                if ord(password[-1]) == NL:
                    password = password[:-1]
        return password

    def get_exp_date(self, *exp):
        '''This method is used to get an expiration date for entries.

        exp is used to display an actual expiration date.

        '''

        edit = ''
        e = KEY_BACKSPACE
        while e != NL:
            if e == KEY_BACKSPACE and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif e == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            elif len(edit) < 4 and e >= 48 and e <= 57:
                edit += chr(e)
            self.draw_text((1,0, 'Special date 2999-12-28 means that the '
                                 'expires never.'),
                           (3,0, 'Year: '),
                           (3,6, edit))
            if exp:
                try:
                    self.stdscr.addstr(2,0, 'Actual expiration date: '+
                                        str(exp[0])+'-'+str(exp[1])+'-'+
                                        str(exp[2]))
                except:
                    pass
                finally:
                    self.stdscr.refresh()
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
        y = int(edit)
            
        edit = ''
        e = KEY_BACKSPACE
        while e != NL:
            if e == KEY_BACKSPACE or e == DEL and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif e == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            elif len(edit) < 2 and e >= 48 and e <= 57:
                edit += chr(e)
            self.draw_text((1,0, 'Special date 2999-12-28 means that the '
                                 'expires never.'),
                           (3,0, 'Year: '+str(y)),
                           (4,0, 'Month: '),
                           (4,7, edit))
            if exp:
                try:
                    self.stdscr.addstr(2,0, 'Actual expiration date: '+
                                        str(exp[0])+'-'+str(exp[1])+'-'+
                                        str(exp[2]))
                except:
                    pass
                finally:
                    self.stdscr.refresh()
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4

            if e == NL and (int(edit) > 12 or int(edit) < 1):
                self.draw_text((1,0, 'Month must be between 1 and 12. Press '
                                     'any key.'))
                self.any_key()
                e = ''
        mon = int(edit)

        edit = ''
        e = KEY_BACKSPACE
        while e != NL:
            if e == KEY_BACKSPACE  or e == DEL and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif e == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            elif len(edit) < 2 and e >= 48 and e <= 57:
                edit += chr(e)
            self.draw_text((1,0, 'Special date 2999-12-28 means that the '
                                 'expires never.'),
                           (3,0, 'Year: '+str(y)),
                           (4,0, 'Month: '+str(mon)),
                           (5,0, 'Day: '),
                           (5,5, edit))
            if exp:
                try:
                    self.stdscr.addstr(2,0, 'Actual expiration date: '+
                                        str(exp[0])+'-'+str(exp[1])+'-'+
                                        str(exp[2]))
                except:
                    pass
                finally:
                    self.stdscr.refresh()
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
           
            if (e == NL and (mon == 1 or mon == 3 or 
                mon == 5 or mon == 7 or mon == 8 or 
                mon == 10 or mon == 12) and
                (int(edit) > 31 or int(edit) < 0)):
                self.draw_text((1,0, 'Day must be between 1 and 31. Press '
                                     'any key.'))
                self.any_key()
                e = ''
            elif (e == NL and mon == 2 and
                  (int(edit) > 28 or int(edit) < 0)):
                self.draw_text((1,0, 'Day must be between 1 and 28. Press '
                                     'any key.'))
                self.any_key()
                e = ''
            elif (e == NL and (mon == 4 or mon == 6 or 
                  mon == 9 or mon == 11) and 
                  (int(edit) > 30 or int(edit) < 0)):
                self.draw_text((1,0, 'Day must be between 1 and 30. Press '
                                     'any key.'))
                self.any_key()
                e = ''
        d = int(edit)
        return y, mon, d

    def ask_for_nav(self, ask_for_lf = True):
        '''Ask for navigation.'''

        if self.last_file is None or ask_for_lf is False:
            self.draw_text((1,0, 'If you want to use the file browser, type \'1\''),
                           (2,0, 'If you want to type a direct path, type \'2\''))
            lf = False
        else:
            self.draw_text((1,0, 'If you want to use the file browser, type \'1\''),
                           (2,0, 'If you want to type a direct path, type \'2\''),
                           (3,0, 'If you want to open '+self.last_file+', type \'3\''))
            lf = True
        e = ''
        while e != NL:
            if e == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif e == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == '':
                pass
            elif e == KEY_RESIZE:
                self.resize_all()
            elif e == ord('e'):
                return e
            elif not ((lf is True and 49 <= e <= 51) or
                (lf is False and 49 <= e <= 50)):
                pass
            else:
                return int(chr(e))
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4

    def ask_for_auth(self):
        '''Ask for authentication.'''

        self.draw_text((1,0, 'If you want to use a password, type \'1\''),
                       (2,0, 'If you want to use a keyfile, type \'2\''),
                       (3,0, 'If you want to use both, type \'3\''))
        e = ''
        while e != NL:
            if e == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif e == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == '':
                pass
            elif e == KEY_RESIZE:
                self.resize_all()
            elif e == ord('e'):
                return False
            elif not 49 <= e <= 51:
                pass
            else:
                return int(chr(e))
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4

    def main_loop(self, kdb_file = None):
        '''The main loop. The program alway return to this method.'''

        if kdb_file is not None:
            self.cur_dir = kdb_file
            if self.open_file() is True:
                self.db_browser()
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
        while True:
            self.draw_text((1,0, 'To open an existing database type \'o\','),
                           (2,0, 'to create a new one type \'n\'.'),
                           (3,0, 'Type \'F1\' for help inside the file '
                                 'or database browser.'),
                           (5,0, 'Type \'q\' to quit.'))
            try:
                c = self.stdscr.getch()
            except KeyboardInterrupt:
                c = 4

            if c == ord('o'):
                if self.open_db() is False:
                    continue
                self.db_browser()
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
            elif c == ord('n'):
                auth = self.ask_for_auth()
                if auth is False:
                    continue
                self.db = KPDB(new = True)
                if auth == 2 or auth == 3:
                    while True:
                        ret = self.get_filepath(False, True)
                        if not isfile(self.db.keyfile):
                            self.draw_text((1,0, 'That\' not a file!'),
                                           (3,0, 'Press any key'))
                            self.any_key()
                            continue
                        break
                    if ret == False: continue;
                    self.db.keyfile = ret
                    if auth != 3: self.db.password = None;
                if auth == 1 or auth == 3:
                    while True:
                        password = self.get_password('Password: ')
                        confirm = self.get_password('Confirm: ')
                        if password == confirm:
                            self.db.password = password
                            break
                        else:
                            self.draw_text((1,0, 'Passwords didn\' match!'),
                                           (3,0, 'Press any key'))
                            self.any_key()
                    if auth != 3: self.db.keyfile = None;
                self.db_browser()
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
            elif c == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif c == KEY_RESIZE:
                self.resize_all()
            elif c == ord('q') or c == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()

    def open_db(self):
        ''' This method opens a database.'''

        nav = self.ask_for_nav()
        if nav == 2:
            while True:
                filepath = self.get_direct_filepath()
                if filepath[-4:] != '.kdb' or isdir(filepath):
                    self.draw_text((1,0, 'Need path to a kdb-file!'),
                                   (3,0, 'Press any key'))
                    self.any_key()
                    return False
                else:
                    self.cur_dir = filepath
                    if self.open_file() is True:
                        break
        elif nav == 3:
            self.cur_dir = self.last_file
            if self.open_file() is False:
                return False
        elif nav == ord('e'):
                return False
        else:
            filepath = self.browser()
            if filepath is False:
                return False
            self.cur_dir = filepath
            if self.open_file() is False:
                return False

    def get_filepath(self, ask_for_lf = True, keyfile = False):
        '''This method is used to get a filepath, e.g. for 'Save as' '''

        nav = self.ask_for_nav(ask_for_lf)
        if nav == 2:
            while True:
                filepath = self.get_direct_filepath()
                if ((filepath[-4:] != '.kdb' or isdir(filepath)) and 
                    keyfile is False):
                    self.draw_text((1,0, 'Need path to a kdb-file!'),
                                   (3,0, 'Press any key'))
                    self.any_key()
                    continue
                else:
                    return filepath
        else:
            if keyfile is True:
                filepath = self.browser(False, keyfile)
            else:
                filepath = self.browser(True)
                if filepath is False:
                    return False
                if filepath[-4:] != '.kdb':
                    filename = self.get_string('', 'Filename: ')
                    filepath += '/'+filename+'.kdb'
            return filepath

    def get_direct_filepath(self):
        '''Get a direct filepath.'''

        e = ''
        show = 0
        rem = []
        cur_dir = ''
        if self.last_file is not None:
            edit = self.last_file
        else:
            edit = ''
        while e != NL:
            if e == KEY_BACKSPACE or e == DEL and len(edit) != 0:
                edit = edit[:-1]
                show = 0
                rem = []
                cur_dir = ''
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif e == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == '':
                pass
            elif e == KEY_RESIZE:
                self.resize_all()
            elif e == ord('~'):
                edit += expanduser('~/')
                show = 0
                rem = []
                cur_dir = ''
            elif e == ord('\t'):
                if cur_dir == '':
                    last = edit.split('/')[-1]
                    cur_dir = edit[:-len(last)]
                try:
                    dir_cont = listdir(cur_dir)
                except OSError:
                    pass
                else:
                    if len(rem) == 0:
                        for i in dir_cont:
                            if i[:len(last)] == last:
                                rem.append(i)
                    if len(rem) > 0:
                        edit = cur_dir+rem[show]
                    else:
                        edit = cur_dir+last
                    if show+1 >= len(rem):
                        show = 0
                    else:
                        show += 1
                    if isdir(edit):
                        edit += '/'
            else:
                show = 0
                rem = []
                cur_dir = ''
                edit += chr(e)

            self.draw_text((1,0, 'Filepath: '), (1,10, edit))
            try:
                e = self.stdscr.getch()
            except KeyboardInterrupt:
                e = 4
        return edit

    def browser(self, mode_new = False, keyfile = False):
        '''A simple file browser.

        mode_new is needed to get a filepath to a new database file.

        '''

        kdb_file = None
        if self.cur_dir[-4:] == '.kdb':
            kdb_file = self.cur_dir.split('/')[-1]
            self.cur_dir = self.cur_dir[:-len(kdb_file)-1]
            kdb_file = self.cur_dir+'/'+kdb_file

        hidden = True
        highlight = 0
        while True:
            self.draw_text()
            try:
                dir_cont = listdir(self.cur_dir)
            except OSError:
                self.draw_text((1,0, 'Was not able to read directory'),
                               (2,0, 'Press any key.'))
                self.any_key()
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
                if self.cur_dir == '': self.cur_dir = '/';
                return False
                
            rem = []
            for i in dir_cont:
                if ((not isdir(self.cur_dir+'/'+i) and not i[-4:] == '.kdb'
                     and keyfile is False) or 
                    (i[0] == '.' and hidden is True)):
                    rem.append(i)
            for i in rem:
                dir_cont.remove(i)
            
            dirs = []
            files = []
            for i in dir_cont:
                if isdir(self.cur_dir+'/'+i):
                    dirs.append(i)
                else:
                    files.append(i)
            dirs.sort()
            files.sort()

            dir_cont = []
            dir_cont.extend(dirs)
            dir_cont.extend(files)
            if not self.cur_dir == '/': dir_cont.insert(0, '..');

            self.show_dir(highlight, dir_cont)
            try:
                c = self.stdscr.getch()
            except KeyboardInterrupt:
                c = 4
            if c == KEY_DOWN or c == ord('j'):
                if highlight >= len(dir_cont)-1:
                    continue
                highlight += 1
                self.show_dir(highlight, dir_cont)
            elif c == KEY_UP or c == ord('k'):
                if highlight <= 0:
                    continue
                highlight -= 1
                self.show_dir(highlight, dir_cont)
            elif c == KEY_LEFT or c == ord('h'):
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
                if self.cur_dir == '': self.cur_dir = '/';
                highlight = 0
            elif c == NL or c == KEY_RIGHT or c == ord('l'):
                if dir_cont[highlight] == '..':
                    last = self.cur_dir.split('/')[-1]
                    self.cur_dir = self.cur_dir[:-len(last)-1]
                    if self.cur_dir == '': self.cur_dir = '/';
                    highlight = 0
                elif isdir(self.cur_dir+'/'+dir_cont[highlight]):
                    self.cur_dir = self.cur_dir+'/'+dir_cont[highlight]
                    if self.cur_dir[:2] == '//':
                        self.cur_dir = self.cur_dir[1:]
                    highlight = 0
                else:
                    if mode_new is False:
                        ret = self.cur_dir+'/'+dir_cont[highlight]
                        if kdb_file is not None:
                            self.cur_dir = kdb_file
                        return ret
                    else:
                        ret = self.cur_dir+'/'+dir_cont[highlight]
                        if kdb_file is not None:
                            self.cur_dir = kdb_file
                        return ret
            elif c == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif c == KEY_RESIZE:
                self.resize_all()
            elif c == KEY_F1 and mode_new is True:
                nocbreak()
                self.stdscr.keypad(0)
                endwin()
                print('Navigate with arrow keys.')
                print('\'o\' - choose directory')
                print('\'e\' - abort')
                print('\'H\' - show/hide hidden files')
                try:
                    input('Press any key')
                except EOFError:
                    print('')
                    if not self.db is None:
                        self.db_close()
                    exit()
                self.stdscr = initscr()
                try:
                    curs_set(0)
                except:
                    print('Invisible cursor not supported')
                cbreak()
                noecho()
                self.stdscr.keypad(1)
                start_color()
                use_default_colors()
                init_pair(1, -1, -1)
                init_pair(2, 2, -1)
                init_pair(3, 0, 1)
                init_pair(4, 6, -1)
                init_pair(5, 0, 6)
                init_pair(6, 0, 7)
                self.stdscr.bkgd(1)
                self.ysize, self.xsize = self.stdscr.getmaxyx()

                self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                        1, 0)
                self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                        int(2*self.xsize/3), 
                                        1, int(self.xsize/3))
                self.info_win = newwin(int((self.ysize-1)/3),
                                       int(2*self.xsize/3),
                                       int(2*(self.ysize-1)/3),
                                       int(self.xsize/3))
                self.group_win.keypad(1)
                self.entry_win.keypad(1)
                self.group_win.bkgd(1)
                self.entry_win.bkgd(1)
                self.info_win.bkgd(1)
                self.stdscr.timeout(20000)
            elif c == KEY_F1:
                nocbreak()
                self.stdscr.keypad(0)
                endwin()
                print('Navigate with arrow keys.')
                print('\'q\' - close program')
                print('\'e\' - abort')
                print('\'H\' - show/hide hidden files')
                try:
                    input('Press any key')
                except EOFError:
                    if not self.db is None:
                        self.db_close()
                    exit()
                self.stdscr = initscr()
                try:
                    curs_set(0)
                except:
                    print('Invisible cursor not supported')
                cbreak()
                noecho()
                self.stdscr.keypad(1)
                start_color()
                use_default_colors()
                init_pair(1, -1, -1)
                init_pair(2, 2, -1)
                init_pair(3, 0, 1)
                init_pair(4, 6, -1)
                init_pair(5, 0, 6)
                init_pair(6, 0, 7)
                self.stdscr.bkgd(1)
                self.stdscr.timeout(20000)
                self.ysize, self.xsize = self.stdscr.getmaxyx()

                self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                        1, 0)
                self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                        int(2*self.xsize/3), 
                                        1, int(self.xsize/3))
                self.info_win = newwin(int((self.ysize-1)/3),
                                       int(2*self.xsize/3),
                                       int(2*(self.ysize-1)/3),
                                       int(self.xsize/3))
                self.group_win.keypad(1)
                self.entry_win.keypad(1)
                self.group_win.bkgd(1)
                self.entry_win.bkgd(1)
                self.info_win.bkgd(1)
                self.stdscr.timeout(20000)
            elif c == ord('H'):
                if hidden == True:
                    hidden = False
                else:
                    hidden = True
            elif c == 4:
                if self.db is not None:
                    self.db_close()
                self.close()
            elif c == ord('q') and mode_new is not True:
                if self.db is not None:
                    self.db_close()
                self.close()
            elif c == ord('e'):
                return False
            elif c == ord('o') and mode_new is True:
                if kdb_file is not None:
                    ret = self.cur_dir
                    self.cur_dir = kdb_file
                    return ret
                else:
                    return self.cur_dir

    def show_dir(self, highlight, dir_cont):
        '''List a directory with highlighting.'''

        for i in range(len(dir_cont)):
            if i == highlight:
                if isdir(self.cur_dir+'/'+dir_cont[i]):
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i], color_pair(5))
                    except:
                        pass
                else:
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i], color_pair(3))
                    except:
                        pass
            else:
                if isdir(self.cur_dir+'/'+dir_cont[i]):
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i], color_pair(4))
                    except:
                        pass
                else:    
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i])
                    except:
                        pass
        self.stdscr.refresh()

    def open_file(self):
        auth = self.ask_for_auth()
        if auth is False:
            return False
        if auth == 1 or auth == 3:
            password = self.get_password('Password: ')
            if auth != 3: keyfile = None;
        if auth == 2 or auth == 3:
            while True:
                keyfile = self.get_filepath(False, True)
                if not isfile(keyfile):
                    self.draw_text((1,0, 'That\'s not a file'),
                                   (3,0, 'Press any key.'))
                    self.any_key()
                    continue
                break
            if auth != 3: password = None
        try:
            if isfile(self.cur_dir+'.lock'):
                self.draw_text((1,0, 'Database seems to be opened.'
                                     ' Open file in read-only mode?'
                                     ' [(y)/n]'))
                while True:
                    try:
                        e = self.stdscr.getch()
                    except KeyboardInterrupt:
                        e = 4

                    if e == ord('n'):
                        self.db = KPDB(self.cur_dir, password, keyfile, False)
                        break
                    elif e == -1:
                        Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                        Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                    elif e == 4:
                        Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                        Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        if self.db is not None:
                            self.db_close()
                        self.close()
                    elif e == KEY_RESIZE:
                        self.resize_all()
                    else:
                        self.db = KPDB(self.cur_dir, password, keyfile, True)
                        break
            else:
                self.db = KPDB(self.cur_dir, password, keyfile, False)
            return True
        except KPError as err:
            self.draw_text((1,0, err.__str__()),
                           (4,0, 'Press any key.'))
            self.any_key()
            last = self.cur_dir.split('/')[-1]
            self.cur_dir = self.cur_dir[:-len(last)-1]
            return False

    def close(self):
        '''Close the program correctly.'''

        nocbreak()
        self.stdscr.keypad(0)
        endwin()
        exit()

    def save(self, cur_dir):
        '''Save the database. cur_dir is the current directory.'''
        self.draw_text((1,0,'Do not interrupt or '
                            'your file will break!'))
        try:
            if cur_dir is False:
                self.db.save()
            else:
                self.db.save(cur_dir)
        except KPError as err:
            self.draw_text((1,0, err.__str__()),
                           (4,0, 'Press any key.'))
            self.any_key()
            return False

    def db_close(self):
        '''Close the database correctly.'''

        if self.db.filepath is not None:
            try:
                self.db.close()
            except KPError as err:
                self.draw_text((1,0, err.__str__()),
                               (4,0, 'Press any key.'))
                self.any_key()
        self.db = None

    def db_browser(self):
        '''The database browser.'''

        if self.cur_dir[-4:] == '.kdb':
            if not isdir(expanduser('~/.config')):
                mkdir(expanduser('~/.config'))
            handler = open(expanduser('~/.config/keepassc'), 'w')
            handler.write(self.cur_dir)
            handler.close()
        
        hide = True
        changed = False
        cur_root = self.db._root_group
        cur_win = 0
        g_highlight = 0
        e_highlight = 0
        g_offset = 0
        e_offset = 0
        self.draw_text()
        self.show_groups(g_highlight, cur_root, cur_win, g_offset)
        self.show_entries(g_highlight, e_highlight, cur_root, cur_win, 
                          e_offset, hide)

        while True:
            try:
                c = self.stdscr.getch()
            except KeyboardInterrupt:
                c = 4
            
            if c == ord('\t'):
                if cur_win == 0:
                    c = KEY_RIGHT
                else:
                    c = KEY_LEFT

            if c == KEY_F1:
                nocbreak()
                self.stdscr.keypad(0)
                endwin()
                print('\'e\' - go to main menu')
                print('\'q\' - close program')
                print('\'x\' - save db and close program')
                print('\'s\' - save db')
                print('\'S\' - save db with alternative filepath')
                print('\'c\' - copy password of current entry')
                print('\'b\' - copy username of current entry')
                print('\'H\' - show password of current entry')
                print('\'o\' - open URL of entry in standard webbrowser')
                print('\'P\' - edit db password')
                print('\'g\' - create group')
                print('\'G\' - create subgroup')
                print('\'y\' - create entry')
                print('\'d\' - delete group or entry')
                print('\'t\' - edit title of selected group or entry')
                print('\'u\' - edit username')
                print('\'p\' - edit password')
                print('\'U\' - edit URL')
                print('\'C\' - edit comment')
                print('\'E\' - edit expiration date')
                print('\'L\' - lock db')
                print('Navigate with arrow keys or h/j/k/l like in vim')
                print('Type \'return\' to enter subgroups')
                print('Type \'backspace\' to go back')
                try:
                    input('Press any key.')
                except EOFError:
                    if not self.db is None:
                        self.db_close()
                    exit()
                self.stdscr = initscr()
                try:
                    curs_set(0)
                except:
                    print('Invisible cursor not supported')
                cbreak()
                noecho()
                self.stdscr.keypad(1)
                start_color()
                use_default_colors()
                init_pair(1, -1, -1)
                init_pair(2, 2, -1)
                init_pair(3, 0, 1)
                init_pair(4, 6, -1)
                init_pair(5, 0, 6)
                init_pair(6, 0, 7)
                self.stdscr.bkgd(1)
                self.ysize, self.xsize = self.stdscr.getmaxyx()

                self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                        1, 0)
                self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                        int(2*self.xsize/3), 
                                        1, int(self.xsize/3))
                self.info_win = newwin(int((self.ysize-1)/3)-1,
                                       int(2*self.xsize/3),
                                       int(2*(self.ysize-1)/3),
                                       int(self.xsize/3))
                self.group_win.keypad(1)
                self.entry_win.keypad(1)
                self.group_win.bkgd(1)
                self.entry_win.bkgd(1)
                self.info_win.bkgd(1)
                self.stdscr.timeout(20000)

                self.draw_text()
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset, hide)
            # File operations
            elif c == ord('e'):
                if changed is True:
                    self.draw_text((1,0, 'File has changed. Save? [(y)/n]'))
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == 4:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        elif e == ord('n'):
                            break
                        else:
                            if self.db.filepath is None:
                                filepath = self.get_filepath()
                                if filepath is not False:
                                    self.cur_dir = filepath
                                    self.save(self.cur_dir)
                            else:
                                self.save(False)
                            break
                self.db_close()
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                self.group_win.clear()
                self.entry_win.clear()
                self.info_win.clear()
                self.group_win.noutrefresh()
                self.entry_win.noutrefresh()
                self.info_win.noutrefresh()
                doupdate()
                break
            elif c == ord('q') or c == 4:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if changed is True:
                    self.draw_text((1,0, 'File has changed. Save? [(y)/n]'))
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == 4:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        elif e == ord('n'):
                            break
                        else:
                            if self.db.filepath is None:
                                filepath = self.get_filepath()
                                if filepath is not False:
                                    self.cur_dir = filepath
                                    self.save(self.cur_dir)
                            else:
                                self.save(False)
                            break
                self.db_close()
                self.close()
            elif c == ord('c'):
                if cur_root.children[g_highlight].entries:
                    entry = cur_root.children[g_highlight].entries[e_highlight]
                    if entry.password is not None:
                        Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                        Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        p = (cur_root.children[g_highlight]
                             .entries[e_highlight]
                             .password)
                        (Popen(['xsel', '-pi'], stdin = PIPE, stderr = PIPE,
                         stdout = PIPE).communicate(p.encode()))
                        (Popen(['xsel', '-bi'], stdin = PIPE, stderr = PIPE,
                         stdout = PIPE).communicate(p.encode()))
            elif c == ord('b'):
                if cur_root.children[g_highlight].entries:
                    entry = cur_root.children[g_highlight].entries[e_highlight]
                    if entry.username is not None:
                        Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                        Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        p = (cur_root.children[g_highlight]
                             .entries[e_highlight]
                             .username)
                        (Popen(['xsel', '-pi'], stdin = PIPE, stderr = PIPE,
                         stdout = PIPE).communicate(p.encode()))
                        (Popen(['xsel', '-bi'], stdin = PIPE, stderr = PIPE,
                         stdout = PIPE).communicate(p.encode()))
            elif c == ord('o'):
                if cur_root.children[g_highlight].entries:
                    entry = cur_root.children[g_highlight].entries[e_highlight]
                    if entry.url != '':
                        webbrowser.open(entry.url)
            elif c == -1:
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
            elif c == ord('s'):
                if self.db.filepath is None:
                    filepath = self.get_filepath()
                    if filepath is not False:
                        self.cur_dir = filepath
                if self.save(self.cur_dir) is not False:
                    changed = False
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset, hide)
            elif c == ord('S'):
                filepath = self.get_filepath(False)
                if filepath is not False:
                    if self.db.filepath is None:
                        self.cur_dir = filepath
                    if isfile(filepath):
                        self.draw_text((1,0, 
                                        'File exists. Overwrite? [y/(n)]'))
                        while True:
                            try:
                                c = self.stdscr.getch()
                            except KeyboardInterrupt:
                                c = 4
                            if c == ord('y'):
                                if self.save(filepath) is not False:
                                    changed = False
                                break
                            elif c == 4:
                                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                                if self.db is not None:
                                    self.db_close()
                                self.close()
                            elif c == -1:
                                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                            elif c == KEY_RESIZE:
                                self.resize_all()
                            else:
                                break
                    else:
                        if self.save(filepath) is not False:
                            changed = False
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset, hide)
                changed = False
            elif c == ord('x'):
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)

                if self.db.filepath is None:
                    filepath = self.get_filepath()
                    if filepath is not False:
                        self.cur_dir = filepath
                        if self.save(self.cur_dir) is not False:
                            self.db_close()
                            self.close()
                elif self.save(self.cur_dir) is not False:
                    self.db_close()
                    self.close()
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset, hide)
            elif c == ord('L'):
                if changed is True:
                    self.draw_text((1,0, 'File has changed. Save? [(y)/n]'))
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == 4:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        elif e == ord('n'):
                            break
                        else:
                            if self.db.filepath is None:
                                filepath = self.get_filepath()
                                if filepath is not False:
                                    self.cur_dir = filepath
                                    self.save(self.cur_dir)
                                    changed = False
                            else:
                                self.save(False)
                                changed = False
                            break
                Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                if self.db.filepath is None:
                    self.draw_text((1,0, 'Can only lock an existing db!'),
                                   (4,0, 'Press any key.'))
                    self.any_key()
                    continue
                self.db.lock()
                while True:
                    auth = self.ask_for_auth()
                    if auth is False:
                        continue
                    if auth == 1 or auth == 3:
                        password = self.get_password('Password: ')
                        if auth != 3: keyfile = None;
                    if auth == 2 or auth == 3:
                        while True:
                            keyfile = self.get_direct_filepath()
                            if not isfile(keyfile):
                                self.draw_text((1,0, 'That\'s not a file'),
                                               (3,0, 'Press any key.'))
                                self.any_key()
                                continue
                            break
                        if auth != 3: password = None
                    try:
                        self.db.unlock(password, keyfile)
                    except KPError as err:
                        self.draw_text((1,0, err.__str__()),
                                       (4,0, 'Press any key.'))
                        self.any_key()
                    else:
                        cur_root = self.db._root_group
                        self.show_groups(g_highlight, cur_root, cur_win, 
                                         g_offset)
                        self.show_entries(g_highlight, e_highlight, cur_root, 
                                          cur_win, e_offset, hide)
                        break
            # DB editing
            elif c == ord('P'):
                auth = self.ask_for_auth()
                if auth is False:
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset, hide)
                    continue
                if auth == 2 or auth == 3:
                    while True:
                        ret = self.get_filepath(False, True)
                        if not isfile(ret):
                            self.draw_text((1,0,"That's not a file!"),
                                           (3,0,'Press any key.'))
                            self.any_key()
                            continue
                        break
                    if ret is False: continue;
                    self.db.keyfile = ret
                    changed = True
                    if auth != 3: self.db.password = None;
                if auth == 1 or auth == 3:
                    password = self.get_password('New Password: ')
                    confirm = self.get_password('Confirm: ')
                    
                    if password == confirm:
                        self.db.password = password
                        changed = True
                    else:
                        try:
                            self.stdscr.addstr(3,0, 'Passwords didn\'t match. '
                                                    'Press any key.')
                        except:
                            pass
                        self.any_key()
                    if auth != 3: self.db.keyfile = None;
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset, hide)
            elif c == ord('g'):
                edit = self.get_string('', 'Title: ')

                try: 
                    if cur_root is self.db._root_group:
                        self.db.create_group(edit)
                    else:
                        self.db.create_group(edit, cur_root)
                except KPError as err:
                    self.draw_text((1,0, err.__str__()),
                                   (4,0, 'Press any key.'))
                    self.any_key()
                else:
                    changed = True
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset, hide)
            elif c == ord('G'):
                if cur_root.children:
                    edit = self.get_string('', 'Title: ')

                    try: 
                        self.db.create_group(edit, cur_root.children[g_highlight])
                    except KPError as err:
                        self.draw_text((1,0, err.__str__()),
                                       (4,0, 'Press any key.'))
                        self.any_key()
                    else:
                        changed = True
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                      e_offset, hide)
            elif c == ord('y'):
                if cur_root.children:
                    self.draw_text((1,0, 'At least one of the following attributes '
                                    'must be given. Press any key'))
                    self.any_key()
                    title = self.get_string('', 'Title: ')
                    url = self.get_string('', 'URL: ')
                    username = self.get_string('', 'Username: ')
                    password = self.get_password('Password: ', False)
                    if password != '':
                        confirm = self.get_password('Confirm: ', False)
                    else:
                        confirm = ''

                    if password != confirm:
                        self.draw_text((1,0, 'Passwords didn\'t match. Will '
                                             'not set this attribute. Press '
                                             'any key.'))
                        self.any_key()
                        password = ''
                    comment = self.get_string('', 'Comment: ')
                    
                    self.draw_text((1,0, 'Set expiration date? [y/(n)]'))
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4

                        if e == ord('y'):
                            y, mon, d = self.get_exp_date()
                            break
                        elif e == 4:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        else:
                            y = 2999
                            mon = 12
                            d = 28
                            break
                    try:
                        cur_root.children[g_highlight].create_entry(title, 1, 
                                                                    url, 
                                                                    username,
                                                                    password,
                                                                    comment,
                                                                    y, mon, d)
                        changed = True
                    except KPError as err:
                        self.draw_text((1,0, err.__str__()),
                                       (4,0, 'Press any key.'))
                        self.any_key()
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset, hide)
            elif c == ord('d'):
                if cur_win == 0 and cur_root.children:
                    title = cur_root.children[g_highlight].title
                    self.draw_text((1,0, 'Really delete group '+title+'? '
                                         '[y/(n)]'))
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == ord('y'):
                            try:
                                cur_root.children[g_highlight].remove_group()
                            except KPError as err:
                                self.draw_text((1,0, err.__str__()),
                                               (4,0, 'Press any key.'))
                                self.any_key()
                            else:
                                if (not cur_root.children and
                                    cur_root is not self.db._root_group):
                                    cur_root = cur_root.parent
                                changed = True

                                if (g_highlight >= len(cur_root.children) and 
                                    g_highlight != 0):
                                    g_highlight -= 1
                                e_highlight = 0
                            finally:
                                break
                        elif e == 4:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        else:
                            break
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset, hide)
                elif cur_win == 1 and cur_root.children:
                    if not cur_root.children[g_highlight].entries:
                        continue
                    title = (cur_root.children[g_highlight]
                             .entries[e_highlight].title)
                    self.draw_text((1,0, 
                                    'Really delete entry '+title+'? [y/(n)]'))
                    while True:
                        try:
                            e = self.stdscr.getch()
                        except KeyboardInterrupt:
                            e = 4
                        if e == ord('y'):
                            try:
                                (cur_root.children[g_highlight]
                                 .entries[e_highlight].remove_entry())
                            except KPError as err:
                                self.draw_text((1,0, err.__str__()),
                                               (4,0, 'Press any key.'))
                                self.any_key()
                            else:
                                changed = True
                                if not cur_root.children[g_highlight].entries:
                                    cur_win = 0
                                entries = cur_root.children[g_highlight].entries
                                if (e_highlight >= len(entries) and
                                    e_highlight != 0):
                                    e_highlight -= 1
                            finally:
                                break
                        elif e == 4:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'], stderr = PIPE, stdout = PIPE)
                            Popen(['xsel', '-bc'], stderr = PIPE, stdout = PIPE)
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        else:
                            break
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset, hide)
            # Edit attributes
            elif (c == ord('t') or c == ord('u') or c == ord('U') or 
                  c == ord('C')):
                if cur_root.children:
                    entries = cur_root.children[g_highlight].entries 
                    if not entries and cur_win == 1:
                        continue
                    if c == ord('t'):
                        std = 'Title: '
                        if cur_win == 0:
                            edit= cur_root.children[g_highlight].title
                        elif cur_win == 1:
                            edit = entries[e_highlight].title
                    elif c == ord('u') and entries:
                        std = 'Username: '
                        edit = entries[e_highlight].username
                    elif c == ord('U') and entries:
                        std = 'URL: '
                        edit = entries[e_highlight].url
                    elif c == ord('C') and entries:
                        std = 'Comment: '
                        edit = entries[e_highlight].comment
                    else:
                        continue
                    edit = self.get_string(edit, std)
                    changed = True

                    if c == ord('t'):
                        if cur_win == 0:
                            cur_root.children[g_highlight].set_title(edit)
                        elif cur_win == 1:
                            entries[e_highlight].set_title(edit)
                    elif c == ord('u'):
                        entries[e_highlight].set_username(edit)
                    elif c == ord('U'):
                        entries[e_highlight].set_url(edit)
                    elif c == ord('C'):
                        entries[e_highlight].set_comment(edit)
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset, hide)
            elif c == ord('p'):
                if cur_root.children:
                    entries = cur_root.children[g_highlight].entries
                    if not entries:
                        continue
                    password = self.get_password('Password: ')
                    confirm = self.get_password('Confirm: ')
                    
                    if password == confirm:
                        entries[e_highlight].set_password(password)
                        changed = True
                    else:
                        try:
                            self.stdscr.addstr(3,0, 'Passwords didn\'t match. '
                                                    'Press any key.')
                        except:
                            pass
                        self.any_key()
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                      e_offset, hide)
            elif c == ord('E'):
                if cur_root.children:
                    entries = cur_root.children[g_highlight].entries
                    if not entries:
                        continue
                    exp = entries[e_highlight].expire.timetuple()
                    y, mon, d = self.get_exp_date(exp[0], exp[1], exp[2])

                    entries[e_highlight].set_expire(y, mon, d, 
                                                    exp[3], exp[4], exp[5])
                    changed = True
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win,
                                      e_offset, hide)
            # Navigation
            elif c == ord('H'):
                if hide is True:
                    hide = False
                else:
                    hide = True
                self.show_entries(g_highlight, e_highlight, cur_root,
                                  cur_win, e_offset, hide)
            elif c == KEY_DOWN or c == ord('j'):
                if cur_win == 0:
                    if g_highlight >= len(cur_root.children)-1:
                        continue
                    ysize = self.group_win.getmaxyx()[0]
                    if (g_highlight >= ysize-4 and 
                        not g_offset >= len(cur_root.children)-ysize+4):
                        g_offset += 1
                    g_highlight += 1
                    e_highlight = 0
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset, hide)
                elif cur_win == 1:
                    entries = cur_root.children[g_highlight].entries
                    if e_highlight >= len(entries)-1:
                        continue
                    ysize = self.entry_win.getmaxyx()[0]
                    entries = cur_root.children[g_highlight].entries
                    if (e_highlight >= ysize-4 and 
                        not e_offset >= len(entries)-ysize+3):
                        e_offset += 1
                    e_highlight += 1
                    self.show_entries(g_highlight, e_highlight, cur_root,
                                      cur_win, e_offset, hide)
            elif c == KEY_UP or c == ord('k'):
                if cur_win == 0:
                    if g_highlight <= 0:
                        continue
                    ysize = self.group_win.getmaxyx()[0]
                    if (g_highlight <= len(cur_root.children)-ysize+4 and 
                        not g_offset <= 0):
                        g_offset -= 1
                    g_highlight -= 1
                    e_highlight = 0
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset, hide)
                elif cur_win == 1:
                    if e_highlight <= 0:
                        continue
                    ysize = self.entry_win.getmaxyx()[0]
                    entries = cur_root.children[g_highlight].entries
                    if e_highlight <= len(entries)-ysize+6 and \
                        not e_offset <= 0:
                        e_offset -= 1
                    e_highlight -= 1
                    self.show_entries(g_highlight, e_highlight, cur_root,
                                      cur_win,  e_offset, hide)
            elif c == KEY_LEFT or c == ord('h'):
                cur_win = 0
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset, hide)
            elif c == KEY_RIGHT or c == ord('l'):
                if cur_root.children[g_highlight].entries:
                    cur_win = 1
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset, hide)
            elif c == KEY_RESIZE:
                self.resize_all()
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset, hide)
            elif c == NL:
                if cur_root.children[g_highlight].children:
                    cur_root = cur_root.children[g_highlight]
                    g_highlight = 0
                    e_highlight = 0
                    cur_win = 0
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset, hide)
            elif c == KEY_BACKSPACE or c == DEL:
                if not cur_root is self.db._root_group:
                    cur_root = cur_root.parent
                    g_highlight = 0
                    e_highlight = 0
                    cur_win = 0
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root,
                                      cur_win, e_offset, hide)
                    
    def show_groups(self, highlight, root, cur_win, offset):
        self.group_win.clear()
        if root is  self.db._root_group:
            root_title = 'Parent: _ROOT_'
        else:
            root_title = 'Parent: '+root.title
        if cur_win == 0:
            h_color = 5
            n_color = 4
        else:
            h_color = 6
            n_color = 1

        try:
            ysize = self.group_win.getmaxyx()[0]
            self.group_win.addstr(0,0, root_title,
                                   color_pair(n_color))
            if root.children:
                groups = root.children
                groups = sorted(groups, key=lambda group: group.title.lower()) 
                if len(groups) <= ysize-3:
                    num = len(groups)
                else:
                    num = ysize-3
                    
                for i in range(num):
                    if highlight == i+offset:
                        if groups[i].children:
                            title = '+'+groups[i+offset].title
                        else:
                            title = ' '+groups[i+offset].title
                        self.group_win.addstr(i+1, 0, title,
                                               color_pair(h_color))
                    else:
                        if groups[i].children:
                            title = '+'+groups[i+offset].title
                        else:
                            title = ' '+groups[i+offset].title
                        self.group_win.addstr(i+1, 0, title,
                                              color_pair(n_color))
                x_of_n = str(highlight+1)+' of '+str(len(groups))
                self.group_win.addstr(ysize-2,0, x_of_n)
        except:
            pass
        finally:
            self.group_win.noutrefresh()

    def show_entries(self, g_highlight, e_highlight, root, cur_win, offset,
                     hide):
        self.info_win.clear()
        try:
            self.entry_win.clear()
            if root.children:
                entries = root.children[g_highlight].entries
                entries = sorted(entries, key=lambda entry: entry.title.lower())
                if entries:
                    if cur_win == 1:
                        h_color = 5
                        n_color = 4
                    else:
                        h_color = 6
                        n_color = 1

                    ysize = self.entry_win.getmaxyx()[0]
                    if len(entries) <= ysize-3:
                        num = len(entries)
                    else:
                        num = ysize-3
                        
                    for i in range(num):
                        title = entries[i+offset].title
                        if e_highlight == i+offset:
                            self.entry_win.addstr(i, 2,  title,
                                                   color_pair(h_color))
                        else:
                            self.entry_win.addstr(i, 2, title,
                                                   color_pair(n_color))
                    self.entry_win.addstr(ysize-2, 2, (str(e_highlight+1)+
                                                        ' of '+
                                                        str(len(entries))))
        except:
            pass
        finally:
            self.entry_win.noutrefresh()

        try:
            if entries:
                entry = entries[e_highlight]
                if entry.title is None:
                    title = ""
                else:
                    title = entry.title
                if entry.group.title is None:
                    group_title = ""
                else:
                    group_title = entry.group.title
                if entry.username is None:
                    username = ""
                else:
                    username = entry.username
                if entry.password is None or hide is True:
                    password = ""
                else:
                    password = entry.password
                if entry.url is None:
                    url = ""
                else:
                    url = entry.url
                if entry.creation is None:
                    creation = ""
                else:
                    creation = entry.creation.__str__()[:10]
                if entry.last_access is None:
                    last_access = ""
                else:
                    last_access = entry.last_access.__str__()[:10]
                if entry.last_mod is None:
                    last_mod = ""
                else:
                    last_mod = entry.last_mod.__str__()[:10]
                if entry.expire is None:
                    expire = ""
                else:
                    if entry.expire.__str__()[:19] == '2999-12-28 23:59:59':
                        expire = "Expires: Never"
                    else:
                        expire = "Expires: "+entry.expire.__str__()[:10]
                if entry.comment is None:
                    comment = ""
                else:
                    comment = entry.comment

                self.info_win.addstr(2,0, title, A_BOLD)
                self.info_win.addstr(3,0, "Group: "+group_title)
                self.info_win.addstr(4,0, "Username: "+username)
                self.info_win.addstr(5,0, "Password: "+password)
                self.info_win.addstr(6,0, "URL: "+url)
                self.info_win.addstr(7,0, "Creation: "+creation)
                self.info_win.addstr(8,0, "Access: "+last_access)
                self.info_win.addstr(9,0, "Modification: "+last_mod)
                self.info_win.addstr(10,0, expire)
                if date.today() > entry.expire.date():
                    self.info_win.addstr(10,22, ' (expired)')
                self.info_win.addstr(11,0, "Comment: "+comment)
        except:
            pass
        finally:
            self.info_win.noutrefresh()
        doupdate()
        
if __name__ == '__main__':
    if geteuid() == 0 and len(argv) == 1:
        print('If you really want to execute this program as root user type \'keepassc --asroot\'')
        print('Warning: This will annul a security concept of keepassc')
    elif geteuid() == 0 and len(argv) >= 2:
        if argv[1] == '--asroot':
            if len(argv) > 2 and argv[2][-4:] == '.kdb':
                filepath = realpath(expanduser(argv[2]))
                app = App()
                wrapper(app.main_loop(filepath))
            else:
                app = App()
                wrapper(app.main_loop())
        else:
            print('If you really want to execute this program as root user type \'keepassc --asroot\'')
            print('Warning: This will annul a security concept of keepassc')
    elif len(argv) >= 2:
        if argv[1][-4:] == '.kdb':
            filepath = realpath(expanduser(argv[1]))
            app = App()
            wrapper(app.main_loop(filepath))
            wrapper(app.main_loop(filepath))
        print('Usage: \'keepassc\'')
        print('Type \'F1\' while running the program to get help.')
    else:
        app = App()
        wrapper(app.main_loop())

