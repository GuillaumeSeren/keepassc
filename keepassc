#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Copyright (C) 2012 Karsten-Kai KÃ¶nig <kkoenig@posteo.de>

This file is part of keepassc.

keepassc is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or at your 
option) any later version.

keepassc is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with keepassc.  If not, see <http://www.gnu.org/licenses/>.
'''

from curses import *
from _curses import error
from curses.ascii import NL, DEL
from datetime import date
from os import *
from os.path import isdir, isfile
from pwd import getpwuid
from socket import gethostname
from subprocess import Popen, PIPE
from sys import exit, argv

from kppy import *

__doc__ = '''This program gives you access to your KeePass 1.x or 
          KeePassX databases through a nice curses interface.

          It is completely controllable with the keyboard.

         '''

class App(object):
    '''This class represents the whole application.'''
    def __init__(self):
        '''The __init__-method. 

        It just initializes some variables and settings and changes
        the working directory to /var/empty to prevent coredumps as
        normal user.

        '''

        self.stdscr = initscr()
        self.ysize, self.xsize = self.stdscr.getmaxyx()
        self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                1, 0)
        self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                int(2*self.xsize/3), 
                                1, int(self.xsize/3))
        self.info_win = newwin(int((self.ysize-1)/3),
                               int(2*self.xsize/3),
                               int(2*(self.ysize-1)/3),
                               int(self.xsize/3))
        curs_set(0)
        cbreak()
        noecho()
        self.stdscr.keypad(1)
        self.group_win.keypad(1)
        self.entry_win.keypad(1)
        start_color()
        use_default_colors()
        init_pair(1, -1, -1)
        init_pair(2, 2, -1)
        init_pair(3, 0, 1)
        init_pair(4, 6, -1)
        init_pair(5, 0, 6)
        init_pair(6, 0, 7)
        self.stdscr.bkgd(1)
        self.group_win.bkgd(1)
        self.entry_win.bkgd(1)
        self.info_win.bkgd(1)
        self.stdscr.timeout(20000)

        self.loginname = getpwuid(geteuid())[0]
        self.hostname = gethostname()
        self.cur_dir = getcwd()
        self.db = None

        chdir('/var/empty')
    
    def resize_all(self):
        self.ysize, self.xsize = self.stdscr.getmaxyx()
        self.group_win.resize(self.ysize-1, int(self.xsize/3))
        self.entry_win.resize(int(2*(self.ysize-1)/3),
                              int(2*self.xsize/3))
        self.info_win.resize(int((self.ysize-1)/3),
                             int(self.xsize/3)-2)
        self.group_win.mvwin(1,0)
        self.entry_win.mvwin(1, int(self.xsize/3))
        self.info_win.mvwin(int(2*(self.ysize-1)/3),
                            int(self.xsize/3))

    def any_key(self):
        '''If any key is needed.'''

        while True:
            e = self.stdscr.getch()
            if e == -1:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
            elif e == 4:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            else:
                break

    def draw_text(self, *misc):
        '''This method is a wrapper to display some text on stdscr.

        misc is a list that should consist of 3-tuples which holds
        text to display.
        (1st element: y-coordinate, 2nd: x-coordinate, 3rd: text)
        '''

        try:
            self.stdscr.clear()
            self.stdscr.addstr(0,0, self.loginname+'@'+self.hostname+':', 
                               color_pair(2))
            self.stdscr.addstr(0, len(self.loginname+'@'+self.hostname+':'),
                               self.cur_dir)
            for i,j,k in misc:
                self.stdscr.addstr(i,j, k)
        except:
            pass
        finally:
            self.stdscr.refresh()

    def get_string(self, edit = '', std = ''):
        '''This method is used to get user input.

        edit is the string to edit and std is text
        which should be displayed in front of edit.
        (std edit)

        '''

        offset = len(std)
        e = ''
        while e != NL:
            if e == KEY_BACKSPACE or e == DEL and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
            elif e == 4:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == '':
                pass
            elif e == KEY_RESIZE:
                self.resize_all()
            else:
                edit += chr(e)

            self.draw_text((1,0,std),(1,offset, edit))
            e = self.stdscr.getch()
        return edit

    def get_password(self, std, needed = True):
        '''This method is used to get a password.

        The pasword will not be displayed during typing.

        std is a string that should be displayed. If needed is True it
        is not possible to return an emptry string.

        '''

        self.draw_text((1,0, std))

        password = ''
        e = ''
        while e != NL or (len(password) == 0 and needed is True):
            e = self.stdscr.getch()
            if e == KEY_BACKSPACE or e == DEL and len(password) != 0:
                password = password[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == '':
                pass
            elif e == -1:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
            elif e == 4:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.ysize, self.xsize = self.stdscr.getmaxyx()
                self.group_win.resize(self.ysize-1, int(self.xsize/3))
                self.entry_win.resize(int(2*(self.ysize-1)/3),
                                      int(2*self.xsize/3))
                self.info_win.resize(int((self.ysize-1)/3),
                                     int(self.xsize/3)-2)
                self.group_win.mvwin(1,0)
                self.entry_win.mvwin(1, int(self.ysize/3))
                self.info_win.mvwin(int(2*(self.ysize-1)/3),
                                    int(self.ysize/3))
            else:
                password += chr(e)
                if ord(password[-1]) == NL:
                    password = password[:-1]
        return password

    def get_exp_date(self, *exp):
        '''This method is used to get an expiration date for entries.

        exp is used to display an actual expiration date.

        '''

        edit = ''
        e = KEY_BACKSPACE
        while e != NL:
            if e == KEY_BACKSPACE and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
            elif e == 4:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            elif len(edit) < 4 and e >= 48 and e <= 57:
                edit += chr(e)
            self.draw_text((1,0, 'Special date 2999-12-28 means that the '
                                 'expires never.'),
                           (3,0, 'Year: '),
                           (3,6, edit))
            if exp:
                try:
                    self.stdscr.addstr(2,0, 'Actual expiration date: '+
                                        str(exp[0])+'-'+str(exp[1])+'-'+
                                        str(exp[2]))
                except:
                    pass
                finally:
                    self.stdscr.refresh()
            e = self.stdscr.getch()
        y = int(edit)
            
        edit = ''
        e = KEY_BACKSPACE
        while e != NL:
            if e == KEY_BACKSPACE or e == DEL and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
            elif e == 4:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            elif len(edit) < 2 and e >= 48 and e <= 57:
                edit += chr(e)
            self.draw_text((1,0, 'Special date 2999-12-28 means that the '
                                 'expires never.'),
                           (3,0, 'Year: '+str(y)),
                           (4,0, 'Month: '),
                           (4,7, edit))
            if exp:
                try:
                    self.stdscr.addstr(2,0, 'Actual expiration date: '+
                                        str(exp[0])+'-'+str(exp[1])+'-'+
                                        str(exp[2]))
                except:
                    pass
                finally:
                    self.stdscr.refresh()
            e = self.stdscr.getch()

            if e == NL and (int(edit) > 12 or int(edit) < 1):
                self.draw_text((1,0, 'Month must be between 1 and 12. Press '
                                     'any key.'))
                self.any_key()
                e = ''
        mon = int(edit)

        edit = ''
        e = KEY_BACKSPACE
        while e != NL:
            if e == KEY_BACKSPACE  or e == DEL and len(edit) != 0:
                edit = edit[:-1]
            elif e == KEY_BACKSPACE or e == DEL:
                pass
            elif e == -1:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
            elif e == 4:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                if self.db is not None:
                    self.db_close()
                self.close()
            elif e == KEY_RESIZE:
                self.resize_all()
            elif len(edit) < 2 and e >= 48 and e <= 57:
                edit += chr(e)
            self.draw_text((1,0, 'Special date 2999-12-28 means that the '
                                 'expires never.'),
                           (3,0, 'Year: '+str(y)),
                           (4,0, 'Month: '+str(mon)),
                           (5,0, 'Day: '),
                           (5,5, edit))
            if exp:
                try:
                    self.stdscr.addstr(2,0, 'Actual expiration date: '+
                                        str(exp[0])+'-'+str(exp[1])+'-'+
                                        str(exp[2]))
                except:
                    pass
                finally:
                    self.stdscr.refresh()
            e = self.stdscr.getch()
           
            if (e == NL and (mon == 1 or mon == 3 or 
                mon == 5 or mon == 7 or mon == 8 or 
                mon == 10 or mon == 12) and
                (int(edit) > 31 or int(edit) < 0)):
                self.draw_text((1,0, 'Day must be between 1 and 31. Press '
                                     'any key.'))
                self.any_key()
                e = ''
            elif (e == NL and mon == 2 and
                  (int(edit) > 28 or int(edit) < 0)):
                self.draw_text((1,0, 'Day must be between 1 and 28. Press '
                                     'any key.'))
                self.any_key()
                e = ''
            elif (e == NL and (mon == 4 or mon == 6 or 
                  mon == 9 or mon == 11) and 
                  (int(edit) > 30 or int(edit) < 0)):
                self.draw_text((1,0, 'Day must be between 1 and 30. Press '
                                     'any key.'))
                self.any_key()
                e = ''
        d = int(edit)
        return y, mon, d

    def main_loop(self, *kdb_file):
        '''The main loop. The program alway return to this method.'''

        while True:
            self.draw_text((1,0, 'To open an existing database type \'o\','),
                           (2,0, 'to create a new one type \'n\'.'),
                           (4,0, 'Type \'q\' to quit.'))
            c = self.stdscr.getch()

            if c == ord('o'):
                ret = self.open_db()
                if ret is False:
                    continue
                self.db_browser()
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
            elif c == ord('n'):
                self.db = KPDB(new = True)
                self.db.masterkey = self.get_password('Password: ')
                self.db_browser()
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
            elif c == -1:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
            elif c == KEY_RESIZE:
                self.resize_all()
            elif c == ord('q') or c == 4:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                if self.db is not None:
                    self.db_close()
                self.close()

    def open_db(self):
        ''' This method opens a database.'''

        hidden = True
        while True:
            filepath = self.browser(hidden = hidden)
            
            if filepath is False:
                continue
            elif filepath == ord('e'):
                return False
            elif filepath == ord('H'):
                if hidden is True:
                    hidden = False
                else:
                    hidden = True
            else:
                self.cur_dir = filepath
                if self.open_file() is True:
                    break

    def get_filepath(self):
        '''This method is used to get a filepath, e.g. for 'Save as' '''

        hidden = True
        while True:
            filepath = self.browser(True, hidden)
            if filepath is False:
                continue
            elif filepath == ord('e'):
                return False
            elif filepath == ord('H'):
                if hidden is True:
                    hidden = False
                else:
                    hidden = True
            else:
                break
        filename = self.get_string('', 'Filename: ')
        filepath += '/'+filename+'.kdb'
        return filepath

    def browser(self, mode_new = False, hidden = True):
        '''A simple file browser.

        mode_new is needed to get a filepath to a new database file.

        '''

        kdb_file = None
        if self.cur_dir[-4:] == '.kdb':
            kdb_file = self.cur_dir.split('/')[-1]
            self.cur_dir = self.cur_dir[:-len(kdb_file)-1]

        self.draw_text()
        try:
            dir_cont = listdir(self.cur_dir)
        except OSError:
            self.draw_text((1,0, 'Was not able to read directory'),
                           (2,0, 'Press any key.'))
            self.any_key()
            last = self.cur_dir.split('/')[-1]
            self.cur_dir = self.cur_dir[:-len(last)-1]
            if self.cur_dir == '': self.cur_dir = '/';
            return False
            
        rem = []
        for i in dir_cont:
            if ((not isdir(self.cur_dir+'/'+i) and not i[-4:] == '.kdb') or
                (i[0] == '.' and hidden is True)):
                rem.append(i)
        for i in rem:
            dir_cont.remove(i)
        
        dirs = []
        files = []
        for i in dir_cont:
            if isdir(self.cur_dir+'/'+i):
                dirs.append(i)
            else:
                files.append(i)
        dirs.sort()
        files.sort()

        dir_cont = []
        dir_cont.extend(dirs)
        dir_cont.extend(files)
        if not self.cur_dir == '/': dir_cont.insert(0, '..');

        highlight = 0
        self.show_dir(highlight, dir_cont)

        while True:
            c = self.stdscr.getch()
            if c == KEY_DOWN:
                if highlight >= len(dir_cont)-1:
                    continue
                highlight += 1
                self.show_dir(highlight, dir_cont)
            elif c == KEY_UP:
                if highlight <= 0:
                    continue
                highlight -= 1
                self.show_dir(highlight, dir_cont)
            elif c == KEY_LEFT:
                last = self.cur_dir.split('/')[-1]
                self.cur_dir = self.cur_dir[:-len(last)-1]
                if self.cur_dir == '': self.cur_dir = '/';
                if kdb_file is not None:
                    self.cur_dir += '/'+kdb_file
                return False
            elif c == NL or c == KEY_RIGHT:
                if dir_cont[highlight] == '..':
                    last = self.cur_dir.split('/')[-1]
                    self.cur_dir = self.cur_dir[:-len(last)-1]
                    if self.cur_dir == '': self.cur_dir = '/';
                    if kdb_file is not None:
                        self.cur_dir += '/'+kdb_file
                    return False
                elif isdir(self.cur_dir+'/'+dir_cont[highlight]):
                    self.cur_dir = self.cur_dir+'/'+dir_cont[highlight]
                    if self.cur_dir[:2] == '//':
                        self.cur_dir = self.cur_dir[1:]
                    if kdb_file is not None:
                        self.cur_dir += '/'+kdb_file
                    return False
                else:
                    if mode_new is False:
                        return self.cur_dir+'/'+dir_cont[highlight]
                    else:
                        if kdb_file is not None:
                            self.cur_dir += '/'+kdb_file
                        return False
            elif c == -1:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
            elif c == KEY_RESIZE:
                self.resize_all()
            elif c == ord('h') and mode_new is True:
                nocbreak()
                self.stdscr.keypad(0)
                endwin()
                print('Navigate with arrow keys.')
                print('\'o\' - choose directory')
                print('\'e\' - abort')
                print('\'H\' - show/hide hidden files')
                try:
                    input('Press any key')
                except EOFError:
                    print('')
                    if not self.db is None:
                        self.db_close()
                    exit()
                self.stdscr = initscr()
                curs_set(0)
                cbreak()
                noecho()
                self.stdscr.keypad(1)
                start_color()
                use_default_colors()
                init_pair(1, -1, -1)
                init_pair(2, 2, -1)
                init_pair(3, 0, 1)
                init_pair(4, 6, -1)
                init_pair(5, 0, 6)
                init_pair(6, 0, 7)
                self.stdscr.bkgd(1)
                self.ysize, self.xsize = self.stdscr.getmaxyx()

                self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                        1, 0)
                self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                        int(2*self.xsize/3), 
                                        1, int(self.xsize/3))
                self.info_win = newwin(int((self.ysize-1)/3),
                                       int(2*self.xsize/3),
                                       int(2*(self.ysize-1)/3),
                                       int(self.xsize/3))
                self.group_win.keypad(1)
                self.entry_win.keypad(1)
                self.group_win.bkgd(1)
                self.entry_win.bkgd(1)
                self.info_win.bkgd(1)
                self.stdscr.timeout(20000)

                return False
            elif c == ord('h'):
                nocbreak()
                self.stdscr.keypad(0)
                endwin()
                print('Navigate with arrow keys.')
                print('\'q\' - close program')
                print('\'e\' - abort')
                print('\'H\' - show/hide hidden files')
                try:
                    input('Press any key')
                except EOFError:
                    if not self.db is None:
                        self.db_close()
                    exit()
                self.stdscr = initscr()
                curs_set(0)
                cbreak()
                noecho()
                self.stdscr.keypad(1)
                start_color()
                use_default_colors()
                init_pair(1, -1, -1)
                init_pair(2, 2, -1)
                init_pair(3, 0, 1)
                init_pair(4, 6, -1)
                init_pair(5, 0, 6)
                init_pair(6, 0, 7)
                self.stdscr.bkgd(1)
                self.stdscr.timeout(20000)
                self.ysize, self.xsize = self.stdscr.getmaxyx()

                self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                        1, 0)
                self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                        int(2*self.xsize/3), 
                                        1, int(self.xsize/3))
                self.info_win = newwin(int((self.ysize-1)/3),
                                       int(2*self.xsize/3),
                                       int(2*(self.ysize-1)/3),
                                       int(self.xsize/3))
                self.group_win.keypad(1)
                self.entry_win.keypad(1)
                self.group_win.bkgd(1)
                self.entry_win.bkgd(1)
                self.info_win.bkgd(1)
                self.stdscr.timeout(20000)

                return False
            elif c == ord('H'):
                return c
            elif c == 4:
                if self.db is not None:
                    self.db_close()
                self.close()
            elif c == ord('q') and mode_new is not True:
                if self.db is not None:
                    self.db_close()
                self.close()
            elif c == ord('e'):
                return c
            elif c == ord('o') and mode_new is True:
                if kdb_file is not None:
                    ret = self.cur_dir
                    self.cur_dir += '/'+kdb_file
                    return ret
                else:
                    return self.cur_dir

    def show_dir(self, highlight, dir_cont):
        '''List a directory with highlighting.'''

        for i in range(len(dir_cont)):
            if i == highlight:
                if isdir(self.cur_dir+'/'+dir_cont[i]):
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i], color_pair(5))
                    except:
                        pass
                else:
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i], color_pair(3))
                    except:
                        pass
            else:
                if isdir(self.cur_dir+'/'+dir_cont[i]):
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i], color_pair(4))
                    except:
                        pass
                else:    
                    try:
                        self.stdscr.addstr(i+1, 0, dir_cont[i])
                    except:
                        pass
        self.stdscr.refresh()

    def open_file(self):
        password = self.get_password('Password: ')
        try:
            if isfile(self.cur_dir+'.lock'):
                self.draw_text((1,0, 'Database seems to be opened.'
                                     ' Open file in read-only mode?'
                                     ' [(y)/n]'))
                while True:
                    e = self.stdscr.getch()

                    if e == ord('n'):
                        self.db = KPDB(self.cur_dir, password, False)
                        break
                    elif e == -1:
                        Popen(['xsel', '-pc'])
                        Popen(['xsel', '-bc'])
                    elif e == 4:
                        Popen(['xsel', '-pc'])
                        Popen(['xsel', '-bc'])
                        if self.db is not None:
                            self.db_close()
                        self.close()
                    elif e == KEY_RESIZE:
                        self.resize_all()
                    else:
                        self.db = KPDB(self.cur_dir, password, True)
                        break
            else:
                self.db = KPDB(self.cur_dir, password, False)
            return True
        except KPError as err:
            self.draw_text((1,0, err.__str__()),
                           (4,0, 'Press any key.'))
            self.any_key()
            last = self.cur_dir.split('/')[-1]
            self.cur_dir = self.cur_dir[:-len(last)-1]
            return False

    def close(self):
        '''Close the program correctly.'''

        nocbreak()
        self.stdscr.keypad(0)
        endwin()
        exit()

    def save(self, cur_dir):
        '''Save the database. cur_dir is the current directory.'''
        
        try:
            if cur_dir is False:
                self.db.save()
            else:
                self.db.save(cur_dir)
        except KPError as err:
            self.draw_text((1,0, err.__str__()),
                           (4,0, 'Press any key.'))
            self.any_key()
            return False

    def db_close(self):
        '''Close the database correctly.'''
        if self.db.filepath is not None:
            try:
                self.db.close()
            except KPError as err:
                self.draw_text((1,0, err.__str__()),
                               (4,0, 'Press any key.'))
                self.any_key()
        self.db = None

    def db_browser(self):
        '''The database browser.'''

        changed = False
        cur_root = self.db._root_group
        cur_win = 0
        g_highlight = 0
        e_highlight = 0
        g_offset = 0
        e_offset = 0
        self.draw_text()
        self.show_groups(g_highlight, cur_root, cur_win, g_offset)
        self.show_entries(g_highlight, e_highlight, cur_root, cur_win, 
                          e_offset)

        while True:
            c = self.stdscr.getch()
            
            if c == ord('\t'):
                if cur_win == 0:
                    c = KEY_RIGHT
                else:
                    c = KEY_LEFT

            if c == ord('h'):
                nocbreak()
                self.stdscr.keypad(0)
                endwin()
                print('\'e\' - go to main menu')
                print('\'q\' - close program')
                print('\'x\' - save db and close program')
                print('\'s\' - save db')
                print('\'S\' - save db with alternative filepath')
                print('\'c\' - copy password of current entry')
                print('\'P\' - edit db password')
                print('\'g\' - create group')
                print('\'G\' - create subgroup')
                print('\'y\' - create entry')
                print('\'d\' - delete group or entry')
                print('\'t\' - edit title of selected group or entry')
                print('\'u\' - edit username')
                print('\'p\' - edit password')
                print('\'U\' - edit URL')
                print('\'C\' - edit comment')
                print('\'E\' - edit expiration date')
                print('\'L\' - lock db')
                print('Navigate with arrow keys')
                print('Type \'return\' to enter subgroups')
                print('Type \'backspace\' to go back')
                try:
                    input('Press any key.')
                except EOFError:
                    if not self.db is None:
                        self.db_close()
                    exit()
                self.stdscr = initscr()
                curs_set(0)
                cbreak()
                noecho()
                self.stdscr.keypad(1)
                start_color()
                use_default_colors()
                init_pair(1, -1, -1)
                init_pair(2, 2, -1)
                init_pair(3, 0, 1)
                init_pair(4, 6, -1)
                init_pair(5, 0, 6)
                init_pair(6, 0, 7)
                self.stdscr.bkgd(1)
                self.ysize, self.xsize = self.stdscr.getmaxyx()

                self.group_win = newwin(self.ysize-1, int(self.xsize/3), 
                                        1, 0)
                self.entry_win = newwin(int(2*(self.ysize-1)/3), 
                                        int(2*self.xsize/3), 
                                        1, int(self.xsize/3))
                self.info_win = newwin(int((self.ysize-1)/3)-1,
                                       int(2*self.xsize/3),
                                       int(2*(self.ysize-1)/3),
                                       int(self.xsize/3))
                self.group_win.keypad(1)
                self.entry_win.keypad(1)
                self.group_win.bkgd(1)
                self.entry_win.bkgd(1)
                self.info_win.bkgd(1)
                self.stdscr.timeout(20000)

                self.draw_text()
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset)
            # File operations
            elif c == ord('e'):
                if changed is True:
                    self.draw_text((1,0, 'File has changed. Save? [(y)/n]'))
                    while True:
                        e = self.stdscr.getch()
                        if e == 4:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        elif e == ord('n'):
                            break
                        else:
                            if self.db.filepath is None:
                                filepath = self.get_filepath()
                                if filepath is not False:
                                    self.cur_dir = filepath
                                    self.save(self.cur_dir)
                            else:
                                self.save(False)
                            break
                self.db_close()
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                self.group_win.clear()
                self.entry_win.clear()
                self.info_win.clear()
                self.group_win.noutrefresh()
                self.entry_win.noutrefresh()
                self.info_win.noutrefresh()
                doupdate()
                break
            elif c == ord('q') or c == 4:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                if changed is True:
                    self.draw_text((1,0, 'File has changed. Save? [(y)/n]'))
                    while True:
                        e = self.stdscr.getch()
                        if e == 4:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        elif e == ord('n'):
                            break
                        else:
                            if self.db.filepath is None:
                                filepath = self.get_filepath()
                                if filepath is not False:
                                    self.cur_dir = filepath
                                    self.save(self.cur_dir)
                            else:
                                self.save(False)
                            break
                self.db_close()
                self.close()
            elif c == ord('c'):
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                p = (cur_root.children[g_highlight].entries[e_highlight]
                     .password)
                Popen(['xsel', '-pi'], stdin = PIPE).communicate(p.encode())
                Popen(['xsel', '-bi'], stdin = PIPE).communicate(p.encode())
            elif c == -1:
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
            elif c == ord('s'):
                if self.db.filepath is None:
                    filepath = self.get_filepath()
                    if filepath is not False:
                        self.cur_dir = filepath
                if self.save(self.cur_dir) is not False:
                    changed = False
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset)
            elif c == ord('S'):
                filepath = self.get_filepath()
                if filepath is not False:
                    if self.db.filepath is None:
                        self.cur_dir = filepath
                    if isfile(filepath):
                        self.draw_text((1,0, 
                                        'File exists. Overwrite? [y/(n)]'))
                        while True:
                            c = self.stdscr.getch()
                            if c == ord('y'):
                                if self.save(filepath) is not False:
                                    changed = False
                                break
                            elif c == 4:
                                Popen(['xsel', '-pc'])
                                Popen(['xsel', '-bc'])
                                if self.db is not None:
                                    self.db_close()
                                self.close()
                            elif c == -1:
                                Popen(['xsel', '-pc'])
                                Popen(['xsel', '-bc'])
                            elif c == KEY_RESIZE:
                                self.resize_all()
                            else:
                                break
                    else:
                        if self.save(filepath) is not False:
                            changed = False
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset)
                changed = False
            elif c == ord('x'):
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])

                if self.db.filepath is None:
                    filepath = self.get_filepath()
                    if filepath is not False:
                        self.cur_dir = filepath
                        if self.save(self.cur_dir) is not False:
                            self.db_close()
                            self.close()
                elif self.save(self.cur_dir) is not False:
                    self.db_close()
                    self.close()
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset)
            elif c == ord('L'):
                Popen(['xsel', '-pc'])
                Popen(['xsel', '-bc'])
                self.db.lock()
                while True:
                    password = self.get_password('Password: ')

                    try:
                        self.db.unlock(password)
                    except KPError as err:
                        self.draw_text((1,0, err.__str__()),
                                       (4,0, 'Press any key.'))
                        self.any_key()
                    else:
                        cur_root = self.db._root_group
                        self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                        self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                          e_offset)
                        break
            # DB editing
            elif c == ord('P'):
                password = self.get_password('New Password: ')
                confirm = self.get_password('Confirm: ')
                
                if password == confirm:
                    self.db.masterkey = password
                    changed = True
                else:
                    try:
                        self.stdscr.addstr(3,0, 'Passwords didn\'t match. '
                                                'Press any key.')
                    except:
                        pass
                    self.any_key()

                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset)
            elif c == ord('g'):
                edit = self.get_string('', 'Title: ')

                try: 
                    if cur_root is self.db._root_group:
                        self.db.create_group(edit)
                    else:
                        self.db.create_group(edit, cur_root)
                except KPError as err:
                    self.draw_text((1,0, err.__str__()),
                                   (4,0, 'Press any key.'))
                    self.any_key()
                else:
                    changed = True
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset)
            elif c == ord('G'):
                if cur_root.children:
                    edit = self.get_string('', 'Title: ')

                    try: 
                        self.db.create_group(edit, cur_root.children[g_highlight])
                    except KPError as err:
                        self.draw_text((1,0, err.__str__()),
                                       (4,0, 'Press any key.'))
                        self.any_key()
                    else:
                        changed = True
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                      e_offset)
            elif c == ord('y'):
                if cur_root.children:
                    self.draw_text((1,0, 'At least one of the following attributes '
                                    'must be given. Press any key'))
                    self.any_key()
                    title = self.get_string('', 'Title: ')
                    url = self.get_string('', 'URL: ')
                    username = self.get_string('', 'Username: ')
                    password = self.get_password('Password: ', False)
                    if password != '':
                        confirm = self.get_password('Confirm: ', False)
                    else:
                        confirm = ''

                    if password != confirm:
                        self.draw_text((1,0, 'Passwords didn\'t match. Will '
                                             'not set this attribute. Press '
                                             'any key.'))
                        self.any_key()
                        password = ''
                    comment = self.get_string('', 'Comment: ')
                    
                    self.draw_text((1,0, 'Set expiration date? [y/(n)]'))
                    while True:
                        e = self.stdscr.getch()

                        if e == ord('y'):
                            y, mon, d = self.get_exp_date()
                            break
                        elif e == 4:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        else:
                            y = 2999
                            mon = 12
                            d = 28
                            break
                    try:
                        cur_root.children[g_highlight].create_entry(title, 1, 
                                                                    url, 
                                                                    username,
                                                                    password,
                                                                    comment,
                                                                    y, mon, d)
                        changed = True
                    except KPError as err:
                        self.draw_text((1,0, err.__str__()),
                                       (4,0, 'Press any key.'))
                        self.any_key()
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset)
            elif c == ord('d'):
                if cur_win == 0 and cur_root.children:
                    title = cur_root.children[g_highlight].title
                    self.draw_text((1,0, 'Really delete group '+title+'? '
                                         '[y/(n)]'))
                    while True:
                        e = self.stdscr.getch()
                        if e == ord('y'):
                            try:
                                cur_root.children[g_highlight].remove_group()
                            except KPError as err:
                                self.draw_text((1,0, err.__str__()),
                                               (4,0, 'Press any key.'))
                                self.any_key()
                            else:
                                if (not cur_root.children and
                                    cur_root is not self.db._root_group):
                                    cur_root = cur_root.parent
                                changed = True

                                if (g_highlight >= len(cur_root.children) and 
                                    g_highlight != 0):
                                    g_highlight -= 1
                                e_highlight = 0
                            finally:
                                break
                        elif e == 4:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        else:
                            break
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset)
                elif cur_win == 1 and cur_root.children:
                    if not cur_root.children[g_highlight].entries:
                        continue
                    title = (cur_root.children[g_highlight]
                             .entries[e_highlight].title)
                    self.draw_text((1,0, 
                                    'Really delete entry '+title+'? [y/(n)]'))
                    while True:
                        e = self.stdscr.getch()
                        if e == ord('y'):
                            try:
                                (cur_root.children[g_highlight]
                                 .entries[e_highlight].remove_entry())
                            except KPError as err:
                                self.draw_text((1,0, err.__str__()),
                                               (4,0, 'Press any key.'))
                                self.any_key()
                            else:
                                changed = True
                                if not cur_root.children[g_highlight].entries:
                                    cur_win = 0
                                entries = cur_root.children[g_highlight].entries
                                if (e_highlight >= len(entries) and
                                    e_highlight != 0):
                                    e_highlight -= 1
                            finally:
                                break
                        elif e == 4:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                            if self.db is not None:
                                self.db_close()
                            self.close()
                        elif e == -1:
                            Popen(['xsel', '-pc'])
                            Popen(['xsel', '-bc'])
                        elif e == KEY_RESIZE:
                            self.resize_all()
                        else:
                            break
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset)
            # Edit attributes
            elif (c == ord('t') or c == ord('u') or c == ord('U') or 
                  c == ord('C')):
                if cur_root.children:
                    entries = cur_root.children[g_highlight].entries 
                    if not entries and cur_win == 1:
                        continue
                    if c == ord('t'):
                        std = 'Title: '
                        if cur_win == 0:
                            edit= cur_root.children[g_highlight].title
                        elif cur_win == 1:
                            edit = entries[e_highlight].title
                    elif c == ord('u') and entries:
                        std = 'Username: '
                        edit = entries[e_highlight].username
                    elif c == ord('U') and entries:
                        std = 'URL: '
                        edit = entries[e_highlight].url
                    elif c == ord('C') and entries:
                        std = 'Comment: '
                        edit = entries[e_highlight].comment
                    else:
                        continue
                    edit = self.get_string(edit, std)
                    changed = True

                    if c == ord('t'):
                        if cur_win == 0:
                            cur_root.children[g_highlight].set_title(edit)
                        elif cur_win == 1:
                            entries[e_highlight].set_title(edit)
                    elif c == ord('u'):
                        entries[e_highlight].set_username(edit)
                    elif c == ord('U'):
                        entries[e_highlight].set_url(edit)
                    elif c == ord('C'):
                        entries[e_highlight].set_comment(edit)
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset)
            elif c == ord('p'):
                if cur_root.children:
                    entries = cur_root.children[g_highlight].entries
                    if not entries:
                        continue
                    password = self.get_password('Password: ')
                    confirm = self.get_password('Confirm: ')
                    
                    if password == confirm:
                        entries[e_highlight].set_password(password)
                        changed = True
                    else:
                        try:
                            self.stdscr.addstr(3,0, 'Passwords didn\'t match. '
                                                    'Press any key.')
                        except:
                            pass
                        self.any_key()
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                      e_offset)
            elif c == ord('E'):
                if cur_root.children:
                    entries = cur_root.children[g_highlight].entries
                    if not entries:
                        continue
                    exp = entries[e_highlight].expire.timetuple()
                    y, mon, d = self.get_exp_date(exp[0], exp[1], exp[2])

                    entries[e_highlight].set_expire(y, mon, d, 
                                                    exp[3], exp[4], exp[5])
                    changed = True
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win,
                                      e_offset)
            # Navigation
            elif c == KEY_DOWN:
                if cur_win == 0:
                    if g_highlight >= len(cur_root.children)-1:
                        continue
                    ysize = self.group_win.getmaxyx()[0]
                    if (g_highlight >= ysize-4 and 
                        not g_offset >= len(cur_root.children)-ysize+4):
                        g_offset += 1
                    g_highlight += 1
                    e_highlight = 0
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset)
                elif cur_win == 1:
                    entries = cur_root.children[g_highlight].entries
                    if e_highlight >= len(entries)-1:
                        continue
                    ysize = self.entry_win.getmaxyx()[0]
                    entries = cur_root.children[g_highlight].entries
                    if (e_highlight >= ysize-4 and 
                        not e_offset >= len(entries)-ysize+3):
                        e_offset += 1
                    e_highlight += 1
                    self.show_entries(g_highlight, e_highlight, cur_root,
                                      cur_win, e_offset)
            elif c == KEY_UP:
                if cur_win == 0:
                    if g_highlight <= 0:
                        continue
                    ysize = self.group_win.getmaxyx()[0]
                    if (g_highlight <= len(cur_root.children)-ysize+4 and 
                        not g_offset <= 0):
                        g_offset -= 1
                    g_highlight -= 1
                    e_highlight = 0
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset)
                elif cur_win == 1:
                    if e_highlight <= 0:
                        continue
                    ysize = self.entry_win.getmaxyx()[0]
                    entries = cur_root.children[g_highlight].entries
                    if e_highlight <= len(entries)-ysize+6 and \
                        not e_offset <= 0:
                        e_offset -= 1
                    e_highlight -= 1
                    self.show_entries(g_highlight, e_highlight, cur_root,
                                      cur_win,  e_offset)
            elif c == KEY_LEFT:
                cur_win = 0
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset)
            elif c == KEY_RIGHT:
                if cur_root.children[g_highlight].entries:
                    cur_win = 1
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset)
            elif c == KEY_RESIZE:
                self.resize_all()
                self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                self.show_entries(g_highlight, e_highlight, cur_root, cur_win,
                                  e_offset)
            elif c == NL:
                if cur_root.children[g_highlight].children:
                    cur_root = cur_root.children[g_highlight]
                    g_highlight = 0
                    e_highlight = 0
                    cur_win = 0
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root, 
                                      cur_win, e_offset)
            elif c == KEY_BACKSPACE or c == DEL:
                if not cur_root is self.db._root_group:
                    cur_root = cur_root.parent
                    g_highlight = 0
                    e_highlight = 0
                    cur_win = 0
                    self.show_groups(g_highlight, cur_root, cur_win, g_offset)
                    self.show_entries(g_highlight, e_highlight, cur_root,
                                      cur_win, e_offset)
                    
    def show_groups(self, highlight, root, cur_win, offset):
        self.group_win.clear()
        if root is  self.db._root_group:
            root_title = 'Parent: _ROOT_'
        else:
            root_title = 'Parent: '+root.title
        if cur_win == 0:
            h_color = 5
            n_color = 4
        else:
            h_color = 6
            n_color = 1

        try:
            ysize = self.group_win.getmaxyx()[0]
            self.group_win.addstr(0,0, root_title,
                                   color_pair(n_color))
            if root.children:
                groups = root.children
                if len(groups) <= ysize-3:
                    num = len(groups)
                else:
                    num = ysize-3
                    
                for i in range(num):
                    if highlight == i+offset:
                        if groups[i].children:
                            title = '+'+groups[i+offset].title
                        else:
                            title = ' '+groups[i+offset].title
                        self.group_win.addstr(i+1, 0, title,
                                               color_pair(h_color))
                    else:
                        if groups[i].children:
                            title = '+'+groups[i+offset].title
                        else:
                            title = ' '+groups[i+offset].title
                        self.group_win.addstr(i+1, 0, title,
                                              color_pair(n_color))
                x_of_n = str(highlight+1)+' of '+str(len(groups))
                self.group_win.addstr(ysize-2,0, x_of_n)
        except:
            pass
        finally:
            self.group_win.noutrefresh()

    def show_entries(self, g_highlight, e_highlight, root, cur_win, offset):
        self.info_win.clear()
        try:
            self.entry_win.clear()
            if root.children:
                entries = root.children[g_highlight].entries
                if entries:
                    if cur_win == 1:
                        h_color = 5
                        n_color = 4
                    else:
                        h_color = 6
                        n_color = 1

                    ysize = self.entry_win.getmaxyx()[0]
                    if len(entries) <= ysize-3:
                        num = len(entries)
                    else:
                        num = ysize-3
                        
                    for i in range(num):
                        title = entries[i+offset].title
                        if e_highlight == i+offset:
                            self.entry_win.addstr(i, 2,  title,
                                                   color_pair(h_color))
                        else:
                            self.entry_win.addstr(i, 2, title,
                                                   color_pair(n_color))
                    self.entry_win.addstr(ysize-2, 2, (str(e_highlight+1)+
                                                        ' of '+
                                                        str(len(entries))))
        except:
            pass
        finally:
            self.entry_win.noutrefresh()

        try:
            if entries:
                entry = entries[e_highlight]
                self.info_win.addstr(2,0, entry.title, A_BOLD)
                self.info_win.addstr(3,0, "Group: "+entry.group.title)
                self.info_win.addstr(4,0, "Username: "+entry.username)
                self.info_win.addstr(5,0, "URL: "+entry.url)
                self.info_win.addstr(6,0, ("Creation: "+entry.creation
                                            .__str__()[:10]))
                self.info_win.addstr(7,0, ("Access: "+entry
                                            .last_access
                                            .__str__()[:10]))
                self.info_win.addstr(8,0, ("Modification: "+entry
                                            .last_mod.__str__()[:10]))
                if (entry.expire
                    .__str__()[:19]) == '2999-12-28 23:59:59':
                    self.info_win.addstr(9,0, "Expires: Never")
                else:
                    self.info_win.addstr(9,0, ("Expires: "+entry
                                                .expire.__str__()[:10]))
                    if date.today() > entry.expire.date():
                        self.info_win.addstr(9,22, ' (expired)')
                self.info_win.addstr(10,0, "Comment: "+entry.comment)
        except:
            pass
        finally:
            self.info_win.noutrefresh()
        doupdate()
        
if __name__ == '__main__':
    if getuid() == 0 and len(argv) < 2:
        print('If you really want to execute this program as root user type \'keepassc --asroot\'')
        print('Warning: This will annul a security concept of keepassc')
    elif getuid() == 0 and len(argv) > 1:
        if argv[1] == '--asroot':
            app = App()
            app.main_loop()
        else:
            print('If you really want to execute this program as root user type \'keepassc --asroot\'')
            print('Warning: This will annul a security concept of keepassc')
    elif len(argv) > 1:
        print('Usage: \'keepassc\'')
        print('Type \'h\' while running the program to get help.')
    else:
        app = App()
        wrapper(app.main_loop())

